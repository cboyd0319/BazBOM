// GitHub PR generation for remediation fixes

use anyhow::{Context, Result};
use bazbom_core::BuildSystem;
use chrono;
use serde_json::json;
use std::path::Path;
use std::process::Command;

use super::apply::apply_fixes_with_testing;
use super::types::{ApplyResultWithTests, PrConfig, RemediationSuggestion};

/// Generate a PR with fixes applied
///
/// This function:
/// 1. Creates a new branch
/// 2. Applies fixes with testing
/// 3. Commits changes
/// 4. Pushes to remote
/// 5. Opens a PR via GitHub API
pub fn generate_pr(
    suggestions: &[RemediationSuggestion],
    build_system: BuildSystem,
    project_root: &Path,
    config: PrConfig,
) -> Result<String> {
    println!("\n[bazbom] Generating PR for vulnerability fixes...");

    let timestamp = chrono::Utc::now().format("%Y%m%d-%H%M%S");
    let branch_name = format!("bazbom/fix-vulnerabilities-{}", timestamp);

    println!("[bazbom] Creating branch: {}", branch_name);

    let status = Command::new("git")
        .args(["checkout", "-b", &branch_name])
        .current_dir(project_root)
        .status()
        .context("Failed to create git branch")?;

    if !status.success() {
        anyhow::bail!("Failed to create branch {}", branch_name);
    }

    println!("\n[bazbom] Applying fixes...");
    let apply_result = apply_fixes_with_testing(suggestions, build_system, project_root, false)?;

    if apply_result.applied.is_empty() {
        println!("[bazbom] No fixes were applied, skipping PR creation");
        let _ = Command::new("git")
            .args(["checkout", "-"])
            .current_dir(project_root)
            .status();
        return Ok("No fixes applied, PR not created".to_string());
    }

    println!("\n[bazbom] Staging changes...");
    let status = Command::new("git")
        .args(["add", "-A"])
        .current_dir(project_root)
        .status()
        .context("Failed to stage changes")?;

    if !status.success() {
        anyhow::bail!("Failed to stage changes");
    }

    let commit_message = generate_commit_message(suggestions, &apply_result);

    println!("[bazbom] Committing changes...");
    let status = Command::new("git")
        .args(["commit", "-m", &commit_message])
        .current_dir(project_root)
        .status()
        .context("Failed to commit changes")?;

    if !status.success() {
        anyhow::bail!("Failed to commit changes");
    }

    println!("[bazbom] Pushing branch to remote...");
    let status = Command::new("git")
        .args(["push", "-u", "origin", &branch_name])
        .current_dir(project_root)
        .status()
        .context("Failed to push branch")?;

    if !status.success() {
        anyhow::bail!("Failed to push branch {}", branch_name);
    }

    let pr_body = generate_pr_body(suggestions, &apply_result);
    let pr_title = generate_pr_title(&apply_result.applied);

    println!("\n[bazbom] Creating pull request...");
    let pr_url = create_github_pr(&config, &pr_title, &pr_body, &branch_name)?;

    println!("\n[+] Pull request created successfully!");
    println!("   URL: {}", pr_url);

    Ok(pr_url)
}

/// Generate commit message
fn generate_commit_message(
    suggestions: &[RemediationSuggestion],
    apply_result: &ApplyResultWithTests,
) -> String {
    let cve_count = apply_result.applied.len();

    let cves: Vec<String> = suggestions
        .iter()
        .filter(|s| s.fixed_version.is_some())
        .take(cve_count)
        .map(|s| s.vulnerability_id.clone())
        .collect();

    let cve_list = if cves.len() <= 3 {
        cves.join(", ")
    } else {
        format!("{} and {} more", cves[..3].join(", "), cves.len() - 3)
    };

    let test_status = if apply_result.tests_passed {
        "All tests passed after applying fixes."
    } else {
        "Tests failed (changes were rolled back)."
    };

    format!(
        "fix: upgrade {} dependencies to fix vulnerabilities\n\n\
         Fixes: {}\n\n\
         Applied {} dependency upgrades to address security vulnerabilities.\n\
         {}\n\n\
         [AI] Generated by BazBOM\n\
         Co-Authored-By: BazBOM <noreply@bazbom.io>",
        cve_count,
        cve_list,
        apply_result.applied.len(),
        test_status
    )
}

/// Generate PR title
fn generate_pr_title(applied: &[String]) -> String {
    let count = applied.len();
    if count == 1 {
        "[S] Fix 1 security vulnerability".to_string()
    } else {
        format!("[S] Fix {} security vulnerabilities", count)
    }
}

/// Generate PR body with detailed information
fn generate_pr_body(
    suggestions: &[RemediationSuggestion],
    apply_result: &ApplyResultWithTests,
) -> String {
    let mut body = String::from("## [S] Security Fixes\n\n");
    body.push_str(
        "This PR automatically upgrades vulnerable dependencies identified by BazBOM.\n\n",
    );

    body.push_str("### Summary\n\n");
    body.push_str(&format!(
        "- [+] **{}** vulnerabilities fixed\n",
        apply_result.applied.len()
    ));
    if !apply_result.failed.is_empty() {
        body.push_str(&format!(
            "- [X] **{}** fixes failed\n",
            apply_result.failed.len()
        ));
    }
    body.push('\n');

    body.push_str("### Vulnerabilities Fixed\n\n");
    body.push_str("| Package | Current | Fixed | Severity | CVE |\n");
    body.push_str("|---------|---------|-------|----------|-----|\n");

    for suggestion in suggestions {
        if let Some(fixed) = &suggestion.fixed_version {
            body.push_str(&format!(
                "| {} | {} | {} | {} | {} |\n",
                suggestion.affected_package,
                suggestion.current_version,
                fixed,
                suggestion.severity,
                suggestion.vulnerability_id
            ));
        }
    }
    body.push('\n');

    body.push_str("### Test Results\n\n");
    if apply_result.tests_passed {
        body.push_str("[+] All tests passed after applying fixes.\n\n");
    } else {
        body.push_str("[X] Tests failed.\n\n");
    }

    body.push_str("### How to Review\n\n");
    body.push_str("1. Review the diff to ensure only dependency versions were changed\n");
    body.push_str("2. Check the CVE details in the table above\n");
    body.push_str("3. Verify that tests pass in CI\n");
    body.push_str("4. Merge if changes look correct\n\n");

    body.push_str("---\n");
    body.push_str("[AI] Generated with [BazBOM](https://github.com/cboyd0319/BazBOM)\n");

    body
}

/// Create a pull request via GitHub API
fn create_github_pr(
    config: &PrConfig,
    title: &str,
    body: &str,
    head_branch: &str,
) -> Result<String> {
    let api_url = format!("https://api.github.com/repos/{}/pulls", config.repo);

    let pr_data = json!({
        "title": title,
        "body": body,
        "head": head_branch,
        "base": config.base_branch,
    });

    let mut response = ureq::post(&api_url)
        .header("Authorization", &format!("token {}", config.token))
        .header("Accept", "application/vnd.github.v3+json")
        .header("User-Agent", "BazBOM/1.0.0")
        .header("Content-Type", "application/json")
        .send(&serde_json::to_string(&pr_data)?)
        .context("Failed to create pull request via GitHub API")?;

    let status = response.status();
    if status != 201 {
        let error_body = response.body_mut().read_to_string().unwrap_or_default();
        anyhow::bail!("GitHub API returned status {}: {}", status, error_body);
    }

    let mut pr_response = response;
    let json_text = pr_response.body_mut().read_to_string()?;
    let pr_data: serde_json::Value =
        serde_json::from_str(&json_text).context("Failed to parse GitHub API response")?;

    let pr_url = pr_data["html_url"]
        .as_str()
        .ok_or_else(|| anyhow::anyhow!("No html_url in GitHub API response"))?
        .to_string();

    Ok(pr_url)
}
