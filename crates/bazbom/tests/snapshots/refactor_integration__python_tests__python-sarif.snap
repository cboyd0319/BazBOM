---
source: crates/bazbom/tests/refactor_integration.rs
expression: sarif
---
{
  "$schema": "https://json.schemastore.org/sarif-2.1.0.json",
  "runs": [
    {
      "results": [
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2022-28346 found in Django. An issue was discovered in Django 2.2 before 2.2.28, 3.2 before 3.2.13, and 4.0 before 4.0.4. `QuerySet.annotate()`, `aggregate()`, and `extra()` methods are subject to SQL injection in column aliases via a crafted dictionary (with dictionary expansion) as the passed `**kwargs`.. EPSS: 12.48%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.1248,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2022-28346"
          },
          "ruleId": "CVE-2022-28346"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2020-13596 found in Django. An issue was discovered in Django version 2.2 before 2.2.13 and 3.0 before 3.0.7. Query parameters generated by the Django admin ForeignKeyRawIdWidget were not properly URL encoded, leading to a possibility of an XSS attack.. EPSS: 0.78%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.00785,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2020-13596"
          },
          "ruleId": "CVE-2020-13596"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2020-9402 found in Django. Django 1.11 before 1.11.29, 2.2 before 2.2.11, and 3.0 before 3.0.4 allows SQL Injection if untrusted data is used as a tolerance parameter in GIS functions and aggregates on Oracle. By passing a suitably crafted tolerance to GIS functions and aggregates on Oracle, it was possible to break escaping and inject malicious SQL.. EPSS: 70.71%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.7071,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2020-9402"
          },
          "ruleId": "CVE-2020-9402"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-45115 found in Django. An issue was discovered in Django 2.2 before 2.2.26, 3.2 before 3.2.11, and 4.0 before 4.0.1. `UserAttributeSimilarityValidator` incurred significant overhead in evaluating a submitted password that was artificially large in relation to the comparison values. In a situation where access to user registration was unrestricted, this provided a potential vector for a denial-of-service attack.. EPSS: 0.77%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.00772,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-45115"
          },
          "ruleId": "CVE-2021-45115"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-33203 found in Django. Django before 2.2.24, 3.x before 3.1.12, and 3.2.x before 3.2.4 has a potential directory traversal via django.contrib.admindocs. Staff members could use the TemplateDetailView view to check the existence of arbitrary files. Additionally, if (and only if) the default admindocs templates have been customized by application developers to also show file contents, then not only the existence but also the file contents would have been exposed. In other words, there is directory traversal outside of the template root directories.. EPSS: 0.71%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.00714,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-33203"
          },
          "ruleId": "CVE-2021-33203"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2019-11358 found in Django. jQuery from 1.1.4 until 3.4.0, as used in Drupal, Backdrop CMS, and other products, mishandles `jQuery.extend(true, {}, ...)` because of `Object.prototype` pollution. If an unsanitized source object contained an enumerable `__proto__` property, it could extend the native `Object.prototype`.. EPSS: 8.07%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.08073,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2019-11358"
          },
          "ruleId": "CVE-2019-11358"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2019-12781 found in Django. An issue was discovered in Django 1.11 before 1.11.22, 2.1 before 2.1.10, and 2.2 before 2.2.3. An HTTP request is not redirected to HTTPS when the SECURE_PROXY_SSL_HEADER and SECURE_SSL_REDIRECT settings are used, and the proxy connects to Django via HTTPS. In other words, django.http.HttpRequest.scheme has incorrect behavior when a client uses HTTP.. EPSS: 5.43%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.0543,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2019-12781"
          },
          "ruleId": "CVE-2019-12781"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2022-23833 found in Django. An issue was discovered in MultiPartParser in Django 2.2 before 2.2.27, 3.2 before 3.2.12, and 4.0 before 4.0.2. Passing certain inputs to multipart forms could result in an infinite loop when parsing files.. EPSS: 7.02%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.07023,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2022-23833"
          },
          "ruleId": "CVE-2022-23833"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2019-14234 found in Django. An issue was discovered in Django 1.11.x before 1.11.23, 2.1.x before 2.1.11, and 2.2.x before 2.2.4. Due to an error in shallow key transformation, key and index lookups for django.contrib.postgres.fields.JSONField, and key lookups for django.contrib.postgres.fields.HStoreField, were subject to SQL injection. This could, for example, be exploited via crafted use of \"OR 1=1\" in a key or index name to return all records, using a suitably crafted dictionary, with dictionary expansion, as the **kwargs passed to the QuerySet.filter() function.. EPSS: 39.73%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.39729,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2019-14234"
          },
          "ruleId": "CVE-2019-14234"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2025-57833 found in Django. An issue was discovered in Django 4.2 before 4.2.24, 5.1 before 5.1.12, and 5.2 before 5.2.6. FilteredRelation is subject to SQL injection in column aliases, using a suitably crafted dictionary, with dictionary expansion, as the **kwargs passed QuerySet.annotate() or QuerySet.alias().. EPSS: 0.06%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.00056,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2025-57833"
          },
          "ruleId": "CVE-2025-57833"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2019-12308 found in Django. An issue was discovered in Django 1.11 before 1.11.21, 2.1 before 2.1.9, and 2.2 before 2.2.2. The clickable Current URL value displayed by the AdminURLFieldWidget displays the provided value without validating it as a safe URL. Thus, an unvalidated value stored in the database, or a value provided as a URL query parameter payload, could result in an clickable JavaScript link.. EPSS: 1.67%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.01672,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2019-12308"
          },
          "ruleId": "CVE-2019-12308"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2025-48432 found in Django. An issue was discovered in Django 5.2 before 5.2.2, 5.1 before 5.1.10, and 4.2 before 4.2.22. Internal HTTP response logging does not escape request.path, which allows remote attackers to potentially manipulate log output via crafted URLs. This may lead to log injection or forgery when logs are viewed in terminals or processed by external systems.. EPSS: 0.46%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.0046,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2025-48432"
          },
          "ruleId": "CVE-2025-48432"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-45116 found in Django. An issue was discovered in Django 2.2 before 2.2.26, 3.2 before 3.2.11, and 4.0 before 4.0.1. Due to leveraging the Django Template Language's variable resolution logic, the dictsort template filter was potentially vulnerable to information disclosure, or an unintended method call, if passed a suitably crafted key.. EPSS: 0.42%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.00416,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-45116"
          },
          "ruleId": "CVE-2021-45116"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2022-36359 found in Django. An issue was discovered in the HTTP FileResponse class in Django 3.2 before 3.2.15 and 4.0 before 4.0.7. An application is vulnerable to a reflected file download (RFD) attack that sets the Content-Disposition header of a FileResponse when the filename is derived from user-supplied input.. EPSS: 1.13%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.01132,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2022-36359"
          },
          "ruleId": "CVE-2022-36359"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2022-22818 found in Django. The `{% debug %}` template tag in Django 2.2 before 2.2.27, 3.2 before 3.2.12, and 4.0 before 4.0.2 does not properly encode the current context. This may lead to XSS.. EPSS: 4.35%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.04347,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2022-22818"
          },
          "ruleId": "CVE-2022-22818"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2019-14232 found in Django. An issue was discovered in Django 1.11.x before 1.11.23, 2.1.x before 2.1.11, and 2.2.x before 2.2.4. If `django.utils.text.Truncator`'s `chars()` and `words()` methods were passed the `html=True` argument, they were extremely slow to evaluate certain inputs due to a catastrophic backtracking vulnerability in a regular expression. The `chars()` and `words()` methods are used to implement the `truncatechars_htm`l and `truncatewords_html` template filters, which were thus vulnerable.. EPSS: 4.57%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.04574,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2019-14232"
          },
          "ruleId": "CVE-2019-14232"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2020-24584 found in Django. An issue was discovered in Django 2.2 before 2.2.16, 3.0 before 3.0.10, and 3.1 before 3.1.1 (when Python 3.7+ is used). The intermediate-level directories of the filesystem cache had the system's standard umask rather than 0o077.. EPSS: 3.67%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.0367,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2020-24584"
          },
          "ruleId": "CVE-2020-24584"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2025-64459 found in Django. An issue was discovered in 5.1 before 5.1.14, 4.2 before 4.2.26, and 5.2 before 5.2.8.\nThe methods `QuerySet.filter()`, `QuerySet.exclude()`, and `QuerySet.get()`, and the class `Q()`, are subject to SQL injection when using a suitably crafted dictionary, with dictionary expansion, as the `_connector` argument.\nEarlier, unsupported Django series (such as 5.0.x, 4.1.x, and 3.2.x) were not evaluated and may also be affected.\nDjango would like to thank cyberstan for reporting this issue.. EPSS: 0.03%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.0003,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2025-64459"
          },
          "ruleId": "CVE-2025-64459"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-3281 found in Django. In Django 2.2 before 2.2.18, 3.0 before 3.0.12, and 3.1 before 3.1.6, the django.utils.archive.extract method (used by \"startapp --template\" and \"startproject --template\") allows directory traversal via an archive with absolute paths or relative paths with dot segments.. EPSS: 3.49%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.03492,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-3281"
          },
          "ruleId": "CVE-2021-3281"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2019-14233 found in Django. An issue was discovered in Django 1.11.x before 1.11.23, 2.1.x before 2.1.11, and 2.2.x before 2.2.4. Due to the behaviour of the underlying HTMLParser, django.utils.html.strip_tags would be extremely slow to evaluate certain inputs containing large sequences of nested incomplete HTML entities.. EPSS: 6.89%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.06895,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2019-14233"
          },
          "ruleId": "CVE-2019-14233"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2020-7471 found in Django. Django 1.11 before 1.11.28, 2.2 before 2.2.10, and 3.0 before 3.0.3 allows SQL Injection if untrusted data is used as a StringAgg delimiter (e.g., in Django applications that offer downloads of data as a series of rows with a user-specified column delimiter). By passing a suitably crafted delimiter to a contrib.postgres.aggregates.StringAgg instance, it was possible to break escaping and inject malicious SQL.. EPSS: 12.48%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.1248,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2020-7471"
          },
          "ruleId": "CVE-2020-7471"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2019-19118 found in Django. Django 2.1 before 2.1.15 and 2.2 before 2.2.8 allows unintended model editing. A Django model admin displaying inline related models, where the user has view-only permissions to a parent model but edit permissions to the inline model, would be presented with an editing UI, allowing POST requests, for updating the inline model. Directly editing the view-only parent model was not possible, but the parent model's save() method was called, triggering potential side effects, and causing pre and post-save signal handlers to be invoked. (To resolve this, the Django admin is adjusted to require edit permissions on the parent model in order for inline models to be editable.). EPSS: 0.31%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.00314,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2019-19118"
          },
          "ruleId": "CVE-2019-19118"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-45452 found in Django. Storage.save in Django 2.2 before 2.2.26, 3.2 before 3.2.11, and 4.0 before 4.0.1 allows directory traversal if crafted filenames are directly passed to it.. EPSS: 0.29%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.00286,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-45452"
          },
          "ruleId": "CVE-2021-45452"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2020-24583 found in Django. An issue was discovered in Django 2.2 before 2.2.16, 3.0 before 3.0.10, and 3.1 before 3.1.1 (when Python 3.7+ is used). FILE_UPLOAD_DIRECTORY_PERMISSIONS mode was not applied to intermediate-level directories created in the process of uploading files. It was also not applied to intermediate-level collected static directories when using the collectstatic management command.. EPSS: 3.82%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.0382,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2020-24583"
          },
          "ruleId": "CVE-2020-24583"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-33571 found in Django. In Django 2.2 before 2.2.24, 3.x before 3.1.12, and 3.2 before 3.2.4, URLValidator, validate_ipv4_address, and validate_ipv46_address do not prohibit leading zero characters in octal literals. This may allow a bypass of access control that is based on IP addresses. (validate_ipv4_address and validate_ipv46_address are unaffected with Python 3.9.5+..) .. EPSS: 0.52%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.00521,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-33571"
          },
          "ruleId": "CVE-2021-33571"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-32052 found in Django. In Django 2.2 before 2.2.22, 3.1 before 3.1.10, and 3.2 before 3.2.2 (with Python 3.9.5+), URLValidator does not prohibit newlines and tabs (unless the URLField form field is used). If an application uses values with newlines in an HTTP response, header injection can occur. Django itself is unaffected because HttpResponse prohibits newlines in HTTP headers.. EPSS: 1.32%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.01321,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-32052"
          },
          "ruleId": "CVE-2021-32052"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2025-64458 found in Django. An issue was discovered in 5.1 before 5.1.14, 4.2 before 4.2.26, and 5.2 before 5.2.8.\nNFKC normalization in Python is slow on Windows. As a consequence, `django.http.HttpResponseRedirect`, `django.http.HttpResponsePermanentRedirect`, and the shortcut `django.shortcuts.redirect`  were subject to a potential  denial-of-service attack via certain inputs with a very large number of Unicode characters.\nEarlier, unsupported Django series (such as 5.0.x, 4.1.x, and 3.2.x) were not evaluated and may also be affected.\nDjango would like to thank Seokchan Yoon for reporting this issue.. EPSS: 0.05%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.00052,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2025-64458"
          },
          "ruleId": "CVE-2025-64458"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2024-45231 found in Django. An issue was discovered in Django v5.1.1, v5.0.9, and v4.2.16. The django.contrib.auth.forms.PasswordResetForm class, when used in a view implementing password reset flows, allows remote attackers to enumerate user e-mail addresses by sending password reset requests and observing the outcome (only when e-mail sending is consistently failing).. EPSS: 0.24%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.00238,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2024-45231"
          },
          "ruleId": "CVE-2024-45231"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-31542 found in Django. In Django 2.2 before 2.2.21, 3.1 before 3.1.9, and 3.2 before 3.2.1, MultiPartParser, UploadedFile, and FieldFile allowed directory traversal via uploaded files with suitably crafted file names.. EPSS: 3.83%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.03831,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-31542"
          },
          "ruleId": "CVE-2021-31542"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-44420 found in Django. In Django 2.2 before 2.2.25, 3.1 before 3.1.14, and 3.2 before 3.2.10, HTTP requests for URLs with trailing newlines could bypass upstream access control based on URL paths. This issue has low severity, according to the Django security policy.. EPSS: 1.61%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.01606,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-44420"
          },
          "ruleId": "CVE-2021-44420"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2019-14235 found in Django. An issue was discovered in Django 1.11.x before 1.11.23, 2.1.x before 2.1.11, and 2.2.x before 2.2.4. If passed certain inputs, django.utils.encoding.uri_to_iri could lead to significant memory usage due to a recursion when repercent-encoding invalid UTF-8 octet sequences.. EPSS: 6.89%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.06895,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2019-14235"
          },
          "ruleId": "CVE-2019-14235"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2019-19844 found in Django. Django before 1.11.27, 2.x before 2.2.9, and 3.x before 3.0.1 allows account takeover. A suitably crafted email address (that is equal to an existing user's email address after case transformation of Unicode characters) would allow an attacker to be sent a password reset token for the matched user account. (One mitigation in the new releases is to send password reset tokens only to the registered user email address.). EPSS: 26.83%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.26835,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2019-19844"
          },
          "ruleId": "CVE-2019-19844"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2022-28347 found in Django. A SQL injection issue was discovered in `QuerySet.explain()` in Django 2.2 before 2.2.28, 3.2 before 3.2.13, and 4.0 before 4.0.4. This occurs by passing a crafted dictionary (with dictionary expansion) as the `**options` argument, and placing the injection payload in an option name.. EPSS: 3.42%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.03424,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2022-28347"
          },
          "ruleId": "CVE-2022-28347"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2020-13254 found in Django. An issue was discovered in Django version 2.2 before 2.2.13 and 3.0 before 3.0.7. In cases where a memcached backend does not perform key validation, passing malformed cache keys could result in a key collision, and potential data leakage.. EPSS: 6.40%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.06396,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2020-13254"
          },
          "ruleId": "CVE-2020-13254"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-28658 found in Django. In Django 2.2 before 2.2.20, 3.0 before 3.0.14, and 3.1 before 3.1.8, MultiPartParser allowed directory traversal via uploaded files with suitably crafted file names. Built-in upload handlers were not affected by this vulnerability.. EPSS: 0.53%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.0053,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-28658"
          },
          "ruleId": "CVE-2021-28658"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2019-12781 found in Django. An issue was discovered in Django 1.11 before 1.11.22, 2.1 before 2.1.10, and 2.2 before 2.2.3. An HTTP request is not redirected to HTTPS when the SECURE_PROXY_SSL_HEADER and SECURE_SSL_REDIRECT settings are used, and the proxy connects to Django via HTTPS. In other words, django.http.HttpRequest.scheme has incorrect behavior when a client uses HTTP.. EPSS: 5.43%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.0543,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2019-12781"
          },
          "ruleId": "CVE-2019-12781"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2019-14232 found in Django. An issue was discovered in Django 1.11.x before 1.11.23, 2.1.x before 2.1.11, and 2.2.x before 2.2.4. If django.utils.text.Truncator's chars() and words() methods were passed the html=True argument, they were extremely slow to evaluate certain inputs due to a catastrophic backtracking vulnerability in a regular expression. The chars() and words() methods are used to implement the truncatechars_html and truncatewords_html template filters, which were thus vulnerable.. EPSS: 4.57%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.04574,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2019-14232"
          },
          "ruleId": "CVE-2019-14232"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2019-14233 found in Django. An issue was discovered in Django 1.11.x before 1.11.23, 2.1.x before 2.1.11, and 2.2.x before 2.2.4. Due to the behaviour of the underlying HTMLParser, django.utils.html.strip_tags would be extremely slow to evaluate certain inputs containing large sequences of nested incomplete HTML entities.. EPSS: 6.89%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.06895,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2019-14233"
          },
          "ruleId": "CVE-2019-14233"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2019-14234 found in Django. An issue was discovered in Django 1.11.x before 1.11.23, 2.1.x before 2.1.11, and 2.2.x before 2.2.4. Due to an error in shallow key transformation, key and index lookups for django.contrib.postgres.fields.JSONField, and key lookups for django.contrib.postgres.fields.HStoreField, were subject to SQL injection. This could, for example, be exploited via crafted use of \"OR 1=1\" in a key or index name to return all records, using a suitably crafted dictionary, with dictionary expansion, as the **kwargs passed to the QuerySet.filter() function.. EPSS: 39.73%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.39729,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2019-14234"
          },
          "ruleId": "CVE-2019-14234"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2019-14235 found in Django. An issue was discovered in Django 1.11.x before 1.11.23, 2.1.x before 2.1.11, and 2.2.x before 2.2.4. If passed certain inputs, django.utils.encoding.uri_to_iri could lead to significant memory usage due to a recursion when repercent-encoding invalid UTF-8 octet sequences.. EPSS: 6.89%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.06895,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2019-14235"
          },
          "ruleId": "CVE-2019-14235"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2019-19118 found in Django. Django 2.1 before 2.1.15 and 2.2 before 2.2.8 allows unintended model editing. A Django model admin displaying inline related models, where the user has view-only permissions to a parent model but edit permissions to the inline model, would be presented with an editing UI, allowing POST requests, for updating the inline model. Directly editing the view-only parent model was not possible, but the parent model's save() method was called, triggering potential side effects, and causing pre and post-save signal handlers to be invoked. (To resolve this, the Django admin is adjusted to require edit permissions on the parent model in order for inline models to be editable.). EPSS: 0.31%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.00314,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2019-19118"
          },
          "ruleId": "CVE-2019-19118"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2019-19844 found in Django. Django before 1.11.27, 2.x before 2.2.9, and 3.x before 3.0.1 allows account takeover. A suitably crafted email address (that is equal to an existing user's email address after case transformation of Unicode characters) would allow an attacker to be sent a password reset token for the matched user account. (One mitigation in the new releases is to send password reset tokens only to the registered user email address.). EPSS: 26.83%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.26835,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2019-19844"
          },
          "ruleId": "CVE-2019-19844"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2019-12308 found in Django. An issue was discovered in Django 1.11 before 1.11.21, 2.1 before 2.1.9, and 2.2 before 2.2.2. The clickable Current URL value displayed by the AdminURLFieldWidget displays the provided value without validating it as a safe URL. Thus, an unvalidated value stored in the database, or a value provided as a URL query parameter payload, could result in an clickable JavaScript link.. EPSS: 1.67%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.01672,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2019-12308"
          },
          "ruleId": "CVE-2019-12308"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2020-13254 found in Django. An issue was discovered in Django 2.2 before 2.2.13 and 3.0 before 3.0.7. In cases where a memcached backend does not perform key validation, passing malformed cache keys could result in a key collision, and potential data leakage.. EPSS: 6.40%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.06396,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2020-13254"
          },
          "ruleId": "CVE-2020-13254"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2020-13596 found in Django. An issue was discovered in Django 2.2 before 2.2.13 and 3.0 before 3.0.7. Query parameters generated by the Django admin ForeignKeyRawIdWidget were not properly URL encoded, leading to a possibility of an XSS attack.. EPSS: 0.78%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.00785,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2020-13596"
          },
          "ruleId": "CVE-2020-13596"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2020-24583 found in Django. An issue was discovered in Django 2.2 before 2.2.16, 3.0 before 3.0.10, and 3.1 before 3.1.1 (when Python 3.7+ is used). FILE_UPLOAD_DIRECTORY_PERMISSIONS mode was not applied to intermediate-level directories created in the process of uploading files. It was also not applied to intermediate-level collected static directories when using the collectstatic management command.. EPSS: 3.82%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.0382,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2020-24583"
          },
          "ruleId": "CVE-2020-24583"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2020-24584 found in Django. An issue was discovered in Django 2.2 before 2.2.16, 3.0 before 3.0.10, and 3.1 before 3.1.1 (when Python 3.7+ is used). The intermediate-level directories of the filesystem cache had the system's standard umask rather than 0o077.. EPSS: 3.67%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.0367,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2020-24584"
          },
          "ruleId": "CVE-2020-24584"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2020-7471 found in Django. Django 1.11 before 1.11.28, 2.2 before 2.2.10, and 3.0 before 3.0.3 allows SQL Injection if untrusted data is used as a StringAgg delimiter (e.g., in Django applications that offer downloads of data as a series of rows with a user-specified column delimiter). By passing a suitably crafted delimiter to a contrib.postgres.aggregates.StringAgg instance, it was possible to break escaping and inject malicious SQL.. EPSS: 12.48%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.1248,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2020-7471"
          },
          "ruleId": "CVE-2020-7471"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2020-9402 found in Django. Django 1.11 before 1.11.29, 2.2 before 2.2.11, and 3.0 before 3.0.4 allows SQL Injection if untrusted data is used as a tolerance parameter in GIS functions and aggregates on Oracle. By passing a suitably crafted tolerance to GIS functions and aggregates on Oracle, it was possible to break escaping and inject malicious SQL.. EPSS: 70.71%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.7071,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2020-9402"
          },
          "ruleId": "CVE-2020-9402"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-44420 found in Django. In Django 2.2 before 2.2.25, 3.1 before 3.1.14, and 3.2 before 3.2.10, HTTP requests for URLs with trailing newlines could bypass upstream access control based on URL paths.. EPSS: 1.61%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.01606,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-44420"
          },
          "ruleId": "CVE-2021-44420"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-28658 found in Django. In Django 2.2 before 2.2.20, 3.0 before 3.0.14, and 3.1 before 3.1.8, MultiPartParser allowed directory traversal via uploaded files with suitably crafted file names. Built-in upload handlers were not affected by this vulnerability.. EPSS: 0.53%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.0053,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-28658"
          },
          "ruleId": "CVE-2021-28658"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-31542 found in Django. In Django 2.2 before 2.2.21, 3.1 before 3.1.9, and 3.2 before 3.2.1, MultiPartParser, UploadedFile, and FieldFile allowed directory traversal via uploaded files with suitably crafted file names.. EPSS: 3.83%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.03831,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-31542"
          },
          "ruleId": "CVE-2021-31542"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-32052 found in Django. In Django 2.2 before 2.2.22, 3.1 before 3.1.10, and 3.2 before 3.2.2 (with Python 3.9.5+), URLValidator does not prohibit newlines and tabs (unless the URLField form field is used). If an application uses values with newlines in an HTTP response, header injection can occur. Django itself is unaffected because HttpResponse prohibits newlines in HTTP headers.. EPSS: 1.32%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.01321,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-32052"
          },
          "ruleId": "CVE-2021-32052"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-3281 found in Django. In Django 2.2 before 2.2.18, 3.0 before 3.0.12, and 3.1 before 3.1.6, the django.utils.archive.extract method (used by \"startapp --template\" and \"startproject --template\") allows directory traversal via an archive with absolute paths or relative paths with dot segments.. EPSS: 3.49%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.03492,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-3281"
          },
          "ruleId": "CVE-2021-3281"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-33203 found in Django. Django before 2.2.24, 3.x before 3.1.12, and 3.2.x before 3.2.4 has a potential directory traversal via django.contrib.admindocs. Staff members could use the TemplateDetailView view to check the existence of arbitrary files. Additionally, if (and only if) the default admindocs templates have been customized by application developers to also show file contents, then not only the existence but also the file contents would have been exposed. In other words, there is directory traversal outside of the template root directories.. EPSS: 0.71%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.00714,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-33203"
          },
          "ruleId": "CVE-2021-33203"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-33571 found in Django. In Django 2.2 before 2.2.24, 3.x before 3.1.12, and 3.2 before 3.2.4, URLValidator, validate_ipv4_address, and validate_ipv46_address do not prohibit leading zero characters in octal literals. This may allow a bypass of access control that is based on IP addresses. (validate_ipv4_address and validate_ipv46_address are unaffected with Python 3.9.5+..) .. EPSS: 0.52%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.00521,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-33571"
          },
          "ruleId": "CVE-2021-33571"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-45115 found in Django. An issue was discovered in Django 2.2 before 2.2.26, 3.2 before 3.2.11, and 4.0 before 4.0.1. UserAttributeSimilarityValidator incurred significant overhead in evaluating a submitted password that was artificially large in relation to the comparison values. In a situation where access to user registration was unrestricted, this provided a potential vector for a denial-of-service attack.. EPSS: 0.77%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.00772,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-45115"
          },
          "ruleId": "CVE-2021-45115"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2022-22818 found in Django. The {% debug %} template tag in Django 2.2 before 2.2.27, 3.2 before 3.2.12, and 4.0 before 4.0.2 does not properly encode the current context. This may lead to XSS.. EPSS: 4.35%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.04347,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2022-22818"
          },
          "ruleId": "CVE-2022-22818"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2022-28346 found in Django. An issue was discovered in Django 2.2 before 2.2.28, 3.2 before 3.2.13, and 4.0 before 4.0.4. QuerySet.annotate(), aggregate(), and extra() methods are subject to SQL injection in column aliases via a crafted dictionary (with dictionary expansion) as the passed **kwargs.. EPSS: 12.48%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.1248,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2022-28346"
          },
          "ruleId": "CVE-2022-28346"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2022-28347 found in Django. A SQL injection issue was discovered in QuerySet.explain() in Django 2.2 before 2.2.28, 3.2 before 3.2.13, and 4.0 before 4.0.4. This occurs by passing a crafted dictionary (with dictionary expansion) as the **options argument, and placing the injection payload in an option name.. EPSS: 3.42%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.03424,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2022-28347"
          },
          "ruleId": "CVE-2022-28347"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-45116 found in Django. An issue was discovered in Django 2.2 before 2.2.26, 3.2 before 3.2.11, and 4.0 before 4.0.1. Due to leveraging the Django Template Language's variable resolution logic, the dictsort template filter was potentially vulnerable to information disclosure, or an unintended method call, if passed a suitably crafted key.. EPSS: 0.42%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.00416,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-45116"
          },
          "ruleId": "CVE-2021-45116"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2022-23833 found in Django. An issue was discovered in MultiPartParser in Django 2.2 before 2.2.27, 3.2 before 3.2.12, and 4.0 before 4.0.2. Passing certain inputs to multipart forms could result in an infinite loop when parsing files.. EPSS: 7.02%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.07023,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2022-23833"
          },
          "ruleId": "CVE-2022-23833"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Django@2.2.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-45452 found in Django. Storage.save in Django 2.2 before 2.2.26, 3.2 before 3.2.11, and 4.0 before 4.0.1 allows directory traversal if crafted filenames are directly passed to it.. EPSS: 0.29%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Django",
            "epss_score": 0.00286,
            "priority": "P3",
            "reachable": true,
            "version": "2.2.0",
            "vulnerability_id": "CVE-2021-45452"
          },
          "ruleId": "CVE-2021-45452"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "requests@2.25.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2024-47081 found in requests. ### Impact\n\nDue to a URL parsing issue, Requests releases prior to 2.32.4 may leak .netrc credentials to third parties for specific maliciously-crafted URLs.\n\n### Workarounds\nFor older versions of Requests, use of the .netrc file can be disabled with `trust_env=False` on your Requests Session ([docs](https://requests.readthedocs.io/en/latest/api/#requests.Session.trust_env)).\n\n### References\nhttps://github.com/psf/requests/pull/6965\nhttps://seclists.org/fulldisclosure/2025/Jun/2. EPSS: 0.09%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "requests",
            "epss_score": 0.0009,
            "priority": "P3",
            "reachable": true,
            "version": "2.25.0",
            "vulnerability_id": "CVE-2024-47081"
          },
          "ruleId": "CVE-2024-47081"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "requests@2.25.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2024-35195 found in requests. When making requests through a Requests `Session`, if the first request is made with `verify=False` to disable cert verification, all subsequent requests to the same origin will continue to ignore cert verification regardless of changes to the value of `verify`. This behavior will continue for the lifecycle of the connection in the connection pool.\n\n### Remediation\nAny of these options can be used to remediate the current issue, we highly recommend upgrading as the preferred mitigation.\n\n* Upgrade to `requests>=2.32.0`.\n* For `requests<2.32.0`, avoid setting `verify=False` for the first request to a host while using a Requests Session.\n* For `requests<2.32.0`, call `close()` on `Session` objects to clear existing connections if `verify=False` is used.\n\n### Related Links\n* https://github.com/psf/requests/pull/6655. EPSS: 0.16%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "requests",
            "epss_score": 0.00164,
            "priority": "P3",
            "reachable": true,
            "version": "2.25.0",
            "vulnerability_id": "CVE-2024-35195"
          },
          "ruleId": "CVE-2024-35195"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "requests@2.25.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2023-32681 found in requests. ### Impact\n\nSince Requests v2.3.0, Requests has been vulnerable to potentially leaking `Proxy-Authorization` headers to destination servers, specifically during redirects to an HTTPS origin. This is a product of how `rebuild_proxies` is used to recompute and [reattach the `Proxy-Authorization` header](https://github.com/psf/requests/blob/f2629e9e3c7ce3c3c8c025bcd8db551101cbc773/requests/sessions.py#L319-L328) to requests when redirected. Note this behavior has _only_ been observed to affect proxied requests when credentials are supplied in the URL user information component (e.g. `https://username:password@proxy:8080`).\n\n**Current vulnerable behavior(s):**\n\n1. HTTP  HTTPS: **leak**\n2. HTTPS  HTTP: **no leak**\n3. HTTPS  HTTPS: **leak**\n4. HTTP  HTTP: **no leak**\n\nFor HTTP connections sent through the proxy, the proxy will identify the header in the request itself and remove it prior to forwarding to the destination server. However when sent over HTTPS, the `Proxy-Authorization` header must be sent in the CONNECT request as the proxy has no visibility into further tunneled requests. This results in Requests forwarding the header to the destination server unintentionally, allowing a malicious actor to potentially exfiltrate those credentials.\n\nThe reason this currently works for HTTPS connections in Requests is the `Proxy-Authorization` header is also handled by urllib3 with our usage of the ProxyManager in adapters.py with [`proxy_manager_for`](https://github.com/psf/requests/blob/f2629e9e3c7ce3c3c8c025bcd8db551101cbc773/requests/adapters.py#L199-L235). This will compute the required proxy headers in `proxy_headers` and pass them to the Proxy Manager, avoiding attaching them directly to the Request object. This will be our preferred option going forward for default usage.\n\n### Patches\nStarting in Requests v2.31.0, Requests will no longer attach this header to redirects with an HTTPS destination. This should have no negative impacts on the default behavior of the library as the proxy credentials are already properly being handled by urllib3's ProxyManager.\n\nFor users with custom adapters, this _may_ be potentially breaking if you were already working around this behavior. The previous functionality of `rebuild_proxies` doesn't make sense in any case, so we would encourage any users impacted to migrate any handling of Proxy-Authorization directly into their custom adapter.\n\n### Workarounds\nFor users who are not able to update Requests immediately, there is one potential workaround.\n\nYou may disable redirects by setting `allow_redirects` to `False` on all calls through Requests top-level APIs. Note that if you're currently relying on redirect behaviors, you will need to capture the 3xx response codes and ensure a new request is made to the redirect destination.\n```\nimport requests\nr = requests.get('http://github.com/', allow_redirects=False)\n```\n\n### Credits\n\nThis vulnerability was discovered and disclosed by the following individuals.\n\nDennis Brinkrolf, Haxolot (https://haxolot.com/)\nTobias Funke, (tobiasfunke93@gmail.com). EPSS: 9.82%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "requests",
            "epss_score": 0.09817,
            "priority": "P3",
            "reachable": true,
            "version": "2.25.0",
            "vulnerability_id": "CVE-2023-32681"
          },
          "ruleId": "CVE-2023-32681"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "requests@2.25.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2023-32681 found in requests. Requests is a HTTP library. Since Requests 2.3.0, Requests has been leaking Proxy-Authorization headers to destination servers when redirected to an HTTPS endpoint. This is a product of how we use `rebuild_proxies` to reattach the `Proxy-Authorization` header to requests. For HTTP connections sent through the tunnel, the proxy will identify the header in the request itself and remove it prior to forwarding to the destination server. However when sent over HTTPS, the `Proxy-Authorization` header must be sent in the CONNECT request as the proxy has no visibility into the tunneled request. This results in Requests forwarding proxy credentials to the destination server unintentionally, allowing a malicious actor to potentially exfiltrate sensitive information. This issue has been patched in version 2.31.0.\n\n. EPSS: 9.82%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "requests",
            "epss_score": 0.09817,
            "priority": "P3",
            "reachable": true,
            "version": "2.25.0",
            "vulnerability_id": "CVE-2023-32681"
          },
          "ruleId": "CVE-2023-32681"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "urllib3@1.26.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2024-37891 found in urllib3. When using urllib3's proxy support with `ProxyManager`, the `Proxy-Authorization` header is only sent to the configured proxy, as expected.\n\nHowever, when sending HTTP requests *without* using urllib3's proxy support, it's possible to accidentally configure the `Proxy-Authorization` header even though it won't have any effect as the request is not using a forwarding proxy or a tunneling proxy. In those cases, urllib3 doesn't treat the `Proxy-Authorization` HTTP header as one carrying authentication material and thus doesn't strip the header on cross-origin redirects.\n\nBecause this is a highly unlikely scenario, we believe the severity of this vulnerability is low for almost all users. Out of an abundance of caution urllib3 will automatically strip the `Proxy-Authorization` header during cross-origin redirects to avoid the small chance that users are doing this on accident.\n\nUsers should use urllib3's proxy support or disable automatic redirects to achieve safe processing of the `Proxy-Authorization` header, but we still decided to strip the header by default in order to further protect users who aren't using the correct approach.\n\n## Affected usages\n\nWe believe the number of usages affected by this advisory is low. It requires all of the following to be true to be exploited:\n\n* Setting the `Proxy-Authorization` header without using urllib3's built-in proxy support.\n* Not disabling HTTP redirects.\n* Either not using an HTTPS origin server or for the proxy or target origin to redirect to a malicious origin.\n\n## Remediation\n\n* Using the `Proxy-Authorization` header with urllib3's `ProxyManager`.\n* Disabling HTTP redirects using `redirects=False` when sending requests.\n* Not using the `Proxy-Authorization` header.. EPSS: 0.28%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "urllib3",
            "epss_score": 0.00282,
            "priority": "P3",
            "reachable": true,
            "version": "1.26.0",
            "vulnerability_id": "CVE-2024-37891"
          },
          "ruleId": "CVE-2024-37891"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "urllib3@1.26.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-28363 found in urllib3. ### Impact\n\nUsers who are using an HTTPS proxy to issue HTTPS requests and haven't configured their own SSLContext via `proxy_config`.\nOnly the default SSLContext is impacted.\n\n### Patches\n\n[urllib3 >=1.26.4 has the issue resolved](https://github.com/urllib3/urllib3/releases/tag/1.26.4). urllib3<1.26 is not impacted due to not supporting HTTPS requests via HTTPS proxies.\n\n### Workarounds\n\nUpgrading is recommended as this is a minor release and not likely to break current usage.\n\nConfiguring an `SSLContext` with `check_hostname=True` and passing via `proxy_config` instead of relying on the default `SSLContext`\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Email us at [sethmichaellarson@gmail.com](mailto:sethmichaellarson@gmail.com). EPSS: 0.47%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "urllib3",
            "epss_score": 0.00466,
            "priority": "P3",
            "reachable": true,
            "version": "1.26.0",
            "vulnerability_id": "CVE-2021-28363"
          },
          "ruleId": "CVE-2021-28363"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "urllib3@1.26.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2023-45803 found in urllib3. urllib3 previously wouldn't remove the HTTP request body when an HTTP redirect response using status 303 \"See Other\" after the request had its method changed from one that could accept a request body (like `POST`) to `GET` as is required by HTTP RFCs. Although the behavior of removing the request body is not specified in the section for redirects, it can be inferred by piecing together information from different sections and we have observed the behavior in other major HTTP client implementations like curl and web browsers.\n\nFrom [RFC 9110 Section 9.3.1](https://www.rfc-editor.org/rfc/rfc9110.html#name-get):\n\n> A client SHOULD NOT generate content in a GET request unless it is made directly to an origin server that has previously indicated, in or out of band, that such a request has a purpose and will be adequately supported.\n\n## Affected usages\n\nBecause the vulnerability requires a previously trusted service to become compromised in order to have an impact on confidentiality we believe the exploitability of this vulnerability is low. Additionally, many users aren't putting sensitive data in HTTP request bodies, if this is the case then this vulnerability isn't exploitable.\n\nBoth of the following conditions must be true to be affected by this vulnerability:\n\n* If you're using urllib3 and submitting sensitive information in the HTTP request body (such as form data or JSON)\n* The origin service is compromised and starts redirecting using 303 to a malicious peer or the redirected-to service becomes compromised.\n\n## Remediation\n\nYou can remediate this vulnerability with any of the following steps:\n\n* Upgrade to a patched version of urllib3 (v1.26.18 or v2.0.7)\n* Disable redirects for services that you aren't expecting to respond with redirects with `redirects=False`.\n* Disable automatic redirects with `redirects=False` and handle 303 redirects manually by stripping the HTTP request body.. EPSS: 0.16%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "urllib3",
            "epss_score": 0.00161,
            "priority": "P3",
            "reachable": true,
            "version": "1.26.0",
            "vulnerability_id": "CVE-2023-45803"
          },
          "ruleId": "CVE-2023-45803"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "urllib3@1.26.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2025-50181 found in urllib3. urllib3 handles redirects and retries using the same mechanism, which is controlled by the `Retry` object. The most common way to disable redirects is at the request level, as follows:\n\n```python\nresp = urllib3.request(\"GET\", \"https://httpbin.org/redirect/1\", redirect=False)\nprint(resp.status)\n# 302\n```\n\nHowever, it is also possible to disable redirects, for all requests, by instantiating a `PoolManager` and specifying `retries` in a way that disable redirects:\n\n```python\nimport urllib3\n\nhttp = urllib3.PoolManager(retries=0)  # should raise MaxRetryError on redirect\nhttp = urllib3.PoolManager(retries=urllib3.Retry(redirect=0))  # equivalent to the above\nhttp = urllib3.PoolManager(retries=False)  # should return the first response\n\nresp = http.request(\"GET\", \"https://httpbin.org/redirect/1\")\n```\n\nHowever, the `retries` parameter is currently ignored, which means all the above examples don't disable redirects.\n\n## Affected usages\n\nPassing `retries` on `PoolManager` instantiation to disable redirects or restrict their number.\n\nBy default, requests and botocore users are not affected.\n\n## Impact\n\nRedirects are often used to exploit SSRF vulnerabilities. An application attempting to mitigate SSRF or open redirect vulnerabilities by disabling redirects at the PoolManager level will remain vulnerable.\n\n## Remediation\n\nYou can remediate this vulnerability with the following steps:\n\n * Upgrade to a patched version of urllib3. If your organization would benefit from the continued support of urllib3 1.x, please contact [sethmichaellarson@gmail.com](mailto:sethmichaellarson@gmail.com) to discuss sponsorship or contribution opportunities.\n * Disable redirects at the `request()` level instead of the `PoolManager()` level.. EPSS: 0.01%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "urllib3",
            "epss_score": 0.00012,
            "priority": "P3",
            "reachable": true,
            "version": "1.26.0",
            "vulnerability_id": "CVE-2025-50181"
          },
          "ruleId": "CVE-2025-50181"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "urllib3@1.26.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-33503 found in urllib3. ### Impact\n\nWhen provided with a URL containing many `@` characters in the authority component the authority regular expression exhibits catastrophic backtracking causing a denial of service if a URL were passed as a parameter or redirected to via an HTTP redirect.\n\n\n### Patches\n\nThe issue has been fixed in urllib3 v1.26.5.\n\n### References\n\n- [CVE-2021-33503](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-33503)\n- [JVNVU#92413403 (English)](https://jvn.jp/en/vu/JVNVU92413403/)\n- [JVNVU#92413403 (Japanese)](https://jvn.jp/vu/JVNVU92413403/)\n- [urllib3 v1.26.5](https://github.com/urllib3/urllib3/releases/tag/1.26.5)\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Ask in our [community Discord](https://discord.gg/urllib3)\n* Email [sethmichaellarson@gmail.com](mailto:sethmichaellarson@gmail.com)\n. EPSS: 0.95%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "urllib3",
            "epss_score": 0.00946,
            "priority": "P3",
            "reachable": true,
            "version": "1.26.0",
            "vulnerability_id": "CVE-2021-33503"
          },
          "ruleId": "CVE-2021-33503"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "urllib3@1.26.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2023-43804 found in urllib3. urllib3 doesn't treat the `Cookie` HTTP header special or provide any helpers for managing cookies over HTTP, that is the responsibility of the user. However, it is possible for a user to specify a `Cookie` header and unknowingly leak information via HTTP redirects to a different origin if that user doesn't disable redirects explicitly.\n\nUsers **must** handle redirects themselves instead of relying on urllib3's automatic redirects to achieve safe processing of the `Cookie` header, thus we decided to strip the header by default in order to further protect users who aren't using the correct approach.\n\n## Affected usages\n\nWe believe the number of usages affected by this advisory is low. It requires all of the following to be true to be exploited:\n\n* Using an affected version of urllib3 (patched in v1.26.17 and v2.0.6)\n* Using the `Cookie` header on requests, which is mostly typical for impersonating a browser.\n* Not disabling HTTP redirects\n* Either not using HTTPS or for the origin server to redirect to a malicious origin.\n\n## Remediation\n\n* Upgrading to at least urllib3 v1.26.17 or v2.0.6\n* Disabling HTTP redirects using `redirects=False` when sending requests.\n* Not using the `Cookie` header.. EPSS: 1.47%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "urllib3",
            "epss_score": 0.01472,
            "priority": "P3",
            "reachable": true,
            "version": "1.26.0",
            "vulnerability_id": "CVE-2023-43804"
          },
          "ruleId": "CVE-2023-43804"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "urllib3@1.26.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-33503 found in urllib3. An issue was discovered in urllib3 before 1.26.5. When provided with a URL containing many @ characters in the authority component, the authority regular expression exhibits catastrophic backtracking, causing a denial of service if a URL were passed as a parameter or redirected to via an HTTP redirect.. EPSS: 0.95%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "urllib3",
            "epss_score": 0.00946,
            "priority": "P3",
            "reachable": true,
            "version": "1.26.0",
            "vulnerability_id": "CVE-2021-33503"
          },
          "ruleId": "CVE-2021-33503"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "urllib3@1.26.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2021-28363 found in urllib3. The urllib3 library 1.26.x before 1.26.4 for Python omits SSL certificate validation in some cases involving HTTPS to HTTPS proxies. The initial connection to the HTTPS proxy (if an SSLContext isn't given via proxy_config) doesn't verify the hostname of the certificate. This means certificates for different servers that still validate properly with the default urllib3 SSLContext will be silently accepted.. EPSS: 0.47%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "urllib3",
            "epss_score": 0.00466,
            "priority": "P3",
            "reachable": true,
            "version": "1.26.0",
            "vulnerability_id": "CVE-2021-28363"
          },
          "ruleId": "CVE-2021-28363"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "urllib3@1.26.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2023-43804 found in urllib3. urllib3 is a user-friendly HTTP client library for Python. urllib3 doesn't treat the `Cookie` HTTP header special or provide any helpers for managing cookies over HTTP, that is the responsibility of the user. However, it is possible for a user to specify a `Cookie` header and unknowingly leak information via HTTP redirects to a different origin if that user doesn't disable redirects explicitly. This issue has been patched in urllib3 version 1.26.17 or 2.0.5.. EPSS: 1.47%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "urllib3",
            "epss_score": 0.01472,
            "priority": "P3",
            "reachable": true,
            "version": "1.26.0",
            "vulnerability_id": "CVE-2023-43804"
          },
          "ruleId": "CVE-2023-43804"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "urllib3@1.26.0"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2023-45803 found in urllib3. urllib3 is a user-friendly HTTP client library for Python. urllib3 previously wouldn't remove the HTTP request body when an HTTP redirect response using status 301, 302, or 303 after the request had its method changed from one that could accept a request body (like `POST`) to `GET` as is required by HTTP RFCs. Although this behavior is not specified in the section for redirects, it can be inferred by piecing together information from different sections and we have observed the behavior in other major HTTP client implementations like curl and web browsers. Because the vulnerability requires a previously trusted service to become compromised in order to have an impact on confidentiality we believe the exploitability of this vulnerability is low. Additionally, many users aren't putting sensitive data in HTTP request bodies, if this is the case then this vulnerability isn't exploitable. Both of the following conditions must be true to be affected by this vulnerability: 1. Using urllib3 and submitting sensitive information in the HTTP request body (such as form data or JSON) and 2. The origin service is compromised and starts redirecting using 301, 302, or 303 to a malicious peer or the redirected-to service becomes compromised. This issue has been addressed in versions 1.26.18 and 2.0.7 and users are advised to update to resolve this issue. Users unable to update should disable redirects for services that aren't expecting to respond with redirects with `redirects=False` and disable automatic redirects with `redirects=False` and handle 301, 302, and 303 redirects manually by stripping the HTTP request body.\n. EPSS: 0.16%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "urllib3",
            "epss_score": 0.00161,
            "priority": "P3",
            "reachable": true,
            "version": "1.26.0",
            "vulnerability_id": "CVE-2023-45803"
          },
          "ruleId": "CVE-2023-45803"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Flask@1.1.1"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2023-30861 found in Flask. When all of the following conditions are met, a response containing data intended for one client may be cached and subsequently sent by a proxy to other clients. If the proxy also caches `Set-Cookie` headers, it may send one client's `session` cookie to other clients. The severity depends on the application's use of the session, and the proxy's behavior regarding cookies. The risk depends on _all_ these conditions being met.\n\n1. The application must be hosted behind a caching proxy that does not strip cookies or ignore responses with cookies.\n2. The application sets [`session.permanent = True`](https://flask.palletsprojects.com/en/2.3.x/api/#flask.session.permanent).\n2. The application does not access or modify the session at any point during a request.\n4. [`SESSION_REFRESH_EACH_REQUEST`](https://flask.palletsprojects.com/en/2.3.x/config/#SESSION_REFRESH_EACH_REQUEST) is enabled (the default).\n5. The application does not set a `Cache-Control` header to indicate that a page is private or should not be cached.\n\nThis happens because vulnerable versions of Flask only set the `Vary: Cookie` header when the session is accessed or modified, not when it is refreshed (re-sent to update the expiration) without being accessed or modified.. EPSS: 0.92%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Flask",
            "epss_score": 0.00915,
            "priority": "P3",
            "reachable": true,
            "version": "1.1.1",
            "vulnerability_id": "CVE-2023-30861"
          },
          "ruleId": "CVE-2023-30861"
        },
        {
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "Flask@1.1.1"
                }
              }
            }
          ],
          "message": {
            "text": "Vulnerability CVE-2023-30861 found in Flask. Flask is a lightweight WSGI web application framework. When all of the following conditions are met, a response containing data intended for one client may be cached and subsequently sent by the proxy to other clients. If the proxy also caches `Set-Cookie` headers, it may send one client's `session` cookie to other clients. The severity depends on the application's use of the session and the proxy's behavior regarding cookies. The risk depends on all these conditions being met.\n\n1. The application must be hosted behind a caching proxy that does not strip cookies or ignore responses with cookies.\n2. The application sets `session.permanent = True`\n3. The application does not access or modify the session at any point during a request.\n4. `SESSION_REFRESH_EACH_REQUEST` enabled (the default).\n5. The application does not set a `Cache-Control` header to indicate that a page is private or should not be cached.\n\nThis happens because vulnerable versions of Flask only set the `Vary: Cookie` header when the session is accessed or modified, not when it is refreshed (re-sent to update the expiration) without being accessed or modified. This issue has been fixed in versions 2.3.2 and 2.2.5.. EPSS: 0.92%. [!] Code is REACHABLE - vulnerability is exploitable"
          },
          "properties": {
            "component": "Flask",
            "epss_score": 0.00915,
            "priority": "P3",
            "reachable": true,
            "version": "1.1.1",
            "vulnerability_id": "CVE-2023-30861"
          },
          "ruleId": "CVE-2023-30861"
        }
      ],
      "tool": {
        "driver": {
          "name": "BazBOM-SCA",
          "rules": [
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2020-9402",
              "shortDescription": {
                "text": "Vulnerability CVE-2020-9402"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2022-28347",
              "shortDescription": {
                "text": "Vulnerability CVE-2022-28347"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2025-57833",
              "shortDescription": {
                "text": "Vulnerability CVE-2025-57833"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2024-37891",
              "shortDescription": {
                "text": "Vulnerability CVE-2024-37891"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2019-19118",
              "shortDescription": {
                "text": "Vulnerability CVE-2019-19118"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2021-31542",
              "shortDescription": {
                "text": "Vulnerability CVE-2021-31542"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2024-47081",
              "shortDescription": {
                "text": "Vulnerability CVE-2024-47081"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2024-45231",
              "shortDescription": {
                "text": "Vulnerability CVE-2024-45231"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2021-33203",
              "shortDescription": {
                "text": "Vulnerability CVE-2021-33203"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2020-13596",
              "shortDescription": {
                "text": "Vulnerability CVE-2020-13596"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2020-24583",
              "shortDescription": {
                "text": "Vulnerability CVE-2020-24583"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2021-32052",
              "shortDescription": {
                "text": "Vulnerability CVE-2021-32052"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2021-3281",
              "shortDescription": {
                "text": "Vulnerability CVE-2021-3281"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2019-11358",
              "shortDescription": {
                "text": "Vulnerability CVE-2019-11358"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2023-30861",
              "shortDescription": {
                "text": "Vulnerability CVE-2023-30861"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2023-43804",
              "shortDescription": {
                "text": "Vulnerability CVE-2023-43804"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2025-64459",
              "shortDescription": {
                "text": "Vulnerability CVE-2025-64459"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2023-32681",
              "shortDescription": {
                "text": "Vulnerability CVE-2023-32681"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2021-28658",
              "shortDescription": {
                "text": "Vulnerability CVE-2021-28658"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2019-14233",
              "shortDescription": {
                "text": "Vulnerability CVE-2019-14233"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2019-14234",
              "shortDescription": {
                "text": "Vulnerability CVE-2019-14234"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2022-28346",
              "shortDescription": {
                "text": "Vulnerability CVE-2022-28346"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2021-44420",
              "shortDescription": {
                "text": "Vulnerability CVE-2021-44420"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2022-36359",
              "shortDescription": {
                "text": "Vulnerability CVE-2022-36359"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2019-12308",
              "shortDescription": {
                "text": "Vulnerability CVE-2019-12308"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2019-12781",
              "shortDescription": {
                "text": "Vulnerability CVE-2019-12781"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2022-23833",
              "shortDescription": {
                "text": "Vulnerability CVE-2022-23833"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2020-13254",
              "shortDescription": {
                "text": "Vulnerability CVE-2020-13254"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2020-24584",
              "shortDescription": {
                "text": "Vulnerability CVE-2020-24584"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2025-64458",
              "shortDescription": {
                "text": "Vulnerability CVE-2025-64458"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2023-45803",
              "shortDescription": {
                "text": "Vulnerability CVE-2023-45803"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2022-22818",
              "shortDescription": {
                "text": "Vulnerability CVE-2022-22818"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2019-14232",
              "shortDescription": {
                "text": "Vulnerability CVE-2019-14232"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2021-45452",
              "shortDescription": {
                "text": "Vulnerability CVE-2021-45452"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2019-14235",
              "shortDescription": {
                "text": "Vulnerability CVE-2019-14235"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2024-35195",
              "shortDescription": {
                "text": "Vulnerability CVE-2024-35195"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2021-33503",
              "shortDescription": {
                "text": "Vulnerability CVE-2021-33503"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2025-50181",
              "shortDescription": {
                "text": "Vulnerability CVE-2025-50181"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2020-7471",
              "shortDescription": {
                "text": "Vulnerability CVE-2020-7471"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2021-45116",
              "shortDescription": {
                "text": "Vulnerability CVE-2021-45116"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2021-28363",
              "shortDescription": {
                "text": "Vulnerability CVE-2021-28363"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2025-48432",
              "shortDescription": {
                "text": "Vulnerability CVE-2025-48432"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2021-45115",
              "shortDescription": {
                "text": "Vulnerability CVE-2021-45115"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2021-33571",
              "shortDescription": {
                "text": "Vulnerability CVE-2021-33571"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "id": "CVE-2019-19844",
              "shortDescription": {
                "text": "Vulnerability CVE-2019-19844"
              }
            }
          ],
          "version": "6.5.0"
        }
      }
    }
  ],
  "version": "2.1.0"
}
