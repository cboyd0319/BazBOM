#!/usr/bin/env python3
"""Master vulnerability enrichment pipeline.

This module orchestrates all enrichment sources (KEV, EPSS, GHSA, VulnCheck)
and provides composite risk scoring and priority mapping.
"""

import json
import sys
from typing import Dict, List, Optional

from kev_enrichment import KEVEnricher
from epss_enrichment import EPSSEnricher
from ghsa_enrichment import GHSAEnricher
from vulncheck_enrichment import VulnCheckEnricher


class VulnerabilityEnricher:
    """Master enrichment pipeline combining all sources."""

    # Risk scoring weights (must sum to 1.0)
    WEIGHT_CVSS = 0.40  # 40% weight
    WEIGHT_EPSS = 0.30  # 30% weight
    WEIGHT_KEV = 0.20   # 20% weight
    WEIGHT_EXPLOIT = 0.10  # 10% weight

    # Priority thresholds
    PRIORITY_P0_THRESHOLD = 80  # Risk score >= 80
    PRIORITY_P1_THRESHOLD = 60
    PRIORITY_P2_THRESHOLD = 40
    PRIORITY_P3_THRESHOLD = 20

    def __init__(
        self,
        kev_cache_dir: str = ".bazel-cache/kev",
        epss_cache_dir: str = ".bazel-cache/epss",
        github_token: Optional[str] = None,
        vulncheck_api_key: Optional[str] = None,
        enable_vulncheck: bool = True,
        enable_ghsa: bool = True
    ):
        """Initialize the enrichment pipeline.
        
        Args:
            kev_cache_dir: Directory for KEV cache
            epss_cache_dir: Directory for EPSS cache
            github_token: GitHub token for GHSA queries (optional)
            vulncheck_api_key: VulnCheck API key (optional)
            enable_vulncheck: Enable VulnCheck enrichment (default: True)
            enable_ghsa: Enable GHSA enrichment (default: True)
        """
        self.kev = KEVEnricher(cache_dir=kev_cache_dir)
        self.epss = EPSSEnricher(cache_dir=epss_cache_dir)
        self.ghsa = GHSAEnricher(github_token=github_token) if enable_ghsa else None
        self.vulncheck = VulnCheckEnricher(api_key=vulncheck_api_key) if enable_vulncheck else None

    def enrich_all(self, findings: List[Dict]) -> List[Dict]:
        """Enrich findings with all available data sources.
        
        Args:
            findings: List of vulnerability finding dictionaries
            
        Returns:
            Enhanced and sorted findings (by risk score, descending)
            
        Raises:
            TypeError: If findings is not a list
        """
        if not isinstance(findings, list):
            raise TypeError(f"Findings must be list, got {type(findings)}")
        
        if not findings:
            return findings

        print(f"Enriching {len(findings)} vulnerability findings...", file=sys.stderr)

        # Step 1: Add EPSS scores (batch operation)
        print("  Step 1/5: Fetching EPSS scores...", file=sys.stderr)
        findings = self.epss.enrich_findings(findings)

        # Step 2: Add KEV status (batch from cache)
        print("  Step 2/5: Checking CISA KEV catalog...", file=sys.stderr)
        for finding in findings:
            if isinstance(finding, dict):
                finding = self.kev.enrich_finding(finding)

        # Step 3: Add exploit intelligence (optional, requires API key)
        if self.vulncheck:
            print("  Step 3/5: Fetching VulnCheck exploit intelligence...", file=sys.stderr)
            for finding in findings:
                if isinstance(finding, dict):
                    finding = self.vulncheck.enrich_finding(finding)
        else:
            print("  Step 3/5: Skipping VulnCheck (disabled or no API key)...", file=sys.stderr)
            # Add empty exploit data
            for finding in findings:
                if isinstance(finding, dict) and "exploit" not in finding:
                    finding["exploit"] = {
                        "exploit_available": False,
                        "weaponized": False
                    }

        # Step 4: Add GHSA remediation guidance
        if self.ghsa:
            print("  Step 4/5: Fetching GitHub Security Advisories...", file=sys.stderr)
            for finding in findings:
                if isinstance(finding, dict):
                    finding = self.ghsa.enrich_finding(finding)
        else:
            print("  Step 4/5: Skipping GHSA (disabled)...", file=sys.stderr)

        # Step 5: Calculate composite risk score and priority
        print("  Step 5/5: Calculating risk scores and priorities...", file=sys.stderr)
        for finding in findings:
            if isinstance(finding, dict):
                finding["risk_score"] = self._calculate_risk_score(finding)
                finding["priority"] = self._calculate_priority(finding)

        # Sort by risk score (highest first)
        findings.sort(key=lambda x: x.get("risk_score", 0) if isinstance(x, dict) else 0, reverse=True)

        print(f"Enrichment complete! Sorted by risk score.", file=sys.stderr)
        return findings

    def _calculate_risk_score(self, finding: Dict) -> float:
        """Calculate composite risk score (0-100).
        
        The risk score combines multiple factors:
        - CVSS base score (40% weight)
        - EPSS exploitation probability (30% weight)
        - KEV catalog presence (20% weight)
        - Exploit availability (10% weight)
        
        Args:
            finding: Vulnerability finding with enrichment data
            
        Returns:
            Risk score from 0.0 to 100.0
        """
        score = 0.0

        # Base CVSS score (0-40 points)
        cvss = finding.get("cvss_score", 0.0)
        if isinstance(cvss, (int, float)):
            score += (cvss / 10.0) * (self.WEIGHT_CVSS * 100)

        # EPSS score (0-30 points)
        epss = finding.get("epss", {}).get("epss_score", 0.0)
        if isinstance(epss, (int, float)):
            score += epss * (self.WEIGHT_EPSS * 100)

        # KEV status (0-20 points)
        if finding.get("kev", {}).get("in_kev"):
            score += self.WEIGHT_KEV * 100

        # Exploit availability (0-10 points)
        exploit = finding.get("exploit", {})
        if exploit.get("weaponized"):
            score += self.WEIGHT_EXPLOIT * 100
        elif exploit.get("exploit_available"):
            score += (self.WEIGHT_EXPLOIT * 100) * 0.5  # Half points for non-weaponized

        return round(score, 2)

    def _calculate_priority(self, finding: Dict) -> str:
        """Calculate actionable priority level.
        
        Priority mapping:
        - P0-IMMEDIATE: In CISA KEV (regardless of risk score)
        - P1-CRITICAL: Risk score >= 80
        - P2-HIGH: Risk score >= 60
        - P3-MEDIUM: Risk score >= 40
        - P4-LOW: Risk score < 40
        
        Args:
            finding: Vulnerability finding with risk score
            
        Returns:
            Priority level string (P0-IMMEDIATE through P4-LOW)
        """
        risk_score = finding.get("risk_score", 0.0)
        in_kev = finding.get("kev", {}).get("in_kev", False)

        # KEV = immediate priority (overrides everything)
        if in_kev:
            return "P0-IMMEDIATE"

        # Risk score-based priority
        if risk_score >= self.PRIORITY_P0_THRESHOLD:
            return "P1-CRITICAL"
        elif risk_score >= self.PRIORITY_P1_THRESHOLD:
            return "P2-HIGH"
        elif risk_score >= self.PRIORITY_P2_THRESHOLD:
            return "P3-MEDIUM"
        else:
            return "P4-LOW"

    def get_priority_summary(self, findings: List[Dict]) -> Dict[str, int]:
        """Get count of findings by priority level.
        
        Args:
            findings: List of enriched findings
            
        Returns:
            Dictionary mapping priority levels to counts
        """
        summary = {
            "P0-IMMEDIATE": 0,
            "P1-CRITICAL": 0,
            "P2-HIGH": 0,
            "P3-MEDIUM": 0,
            "P4-LOW": 0
        }
        
        for finding in findings:
            if isinstance(finding, dict):
                priority = finding.get("priority", "P4-LOW")
                if priority in summary:
                    summary[priority] += 1
        
        return summary


def main():
    """CLI for testing vulnerability enrichment pipeline."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Enrich vulnerability findings with KEV, EPSS, GHSA, and VulnCheck data"
    )
    parser.add_argument(
        "input",
        help="Input JSON file with vulnerability findings"
    )
    parser.add_argument(
        "--output",
        help="Output file for enriched findings (default: stdout)"
    )
    parser.add_argument(
        "--github-token",
        help="GitHub token for GHSA queries (or set GITHUB_TOKEN env var)"
    )
    parser.add_argument(
        "--vulncheck-api-key",
        help="VulnCheck API key (or set VULNCHECK_API_KEY env var)"
    )
    parser.add_argument(
        "--disable-vulncheck",
        action="store_true",
        help="Disable VulnCheck enrichment"
    )
    parser.add_argument(
        "--disable-ghsa",
        action="store_true",
        help="Disable GHSA enrichment"
    )
    parser.add_argument(
        "--summary",
        action="store_true",
        help="Print priority summary to stderr"
    )
    
    args = parser.parse_args()
    
    try:
        # Load input findings
        with open(args.input, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        # Extract findings array
        if isinstance(data, dict):
            findings = data.get("vulnerabilities", data.get("findings", []))
        elif isinstance(data, list):
            findings = data
        else:
            print(f"Error: Invalid input format", file=sys.stderr)
            return 1
        
        # Create enricher
        enricher = VulnerabilityEnricher(
            github_token=args.github_token,
            vulncheck_api_key=args.vulncheck_api_key,
            enable_vulncheck=not args.disable_vulncheck,
            enable_ghsa=not args.disable_ghsa
        )
        
        # Enrich findings
        enriched_findings = enricher.enrich_all(findings)
        
        # Prepare output
        if isinstance(data, dict):
            output_data = {
                "scan_date": data.get("scan_date", ""),
                "packages_scanned": data.get("packages_scanned", 0),
                "vulnerabilities_found": len(enriched_findings),
                "vulnerabilities": enriched_findings
            }
        else:
            # data was a list
            output_data = {
                "scan_date": "",
                "packages_scanned": 0,
                "vulnerabilities_found": len(enriched_findings),
                "vulnerabilities": enriched_findings
            }
        
        # Print summary if requested
        if args.summary:
            summary = enricher.get_priority_summary(enriched_findings)
            print("\n Vulnerability Priority Summary:", file=sys.stderr)
            print(f"  [ALERT] P0 - IMMEDIATE (KEV):     {summary['P0-IMMEDIATE']}", file=sys.stderr)
            print(f"  [CRITICAL] P1 - CRITICAL:            {summary['P1-CRITICAL']}", file=sys.stderr)
            print(f"  [HIGH] P2 - HIGH:                {summary['P2-HIGH']}", file=sys.stderr)
            print(f"  [MEDIUM] P3 - MEDIUM:              {summary['P3-MEDIUM']}", file=sys.stderr)
            print(f"  [LOW] P4 - LOW:                 {summary['P4-LOW']}", file=sys.stderr)
            print(f"  Total:                       {len(enriched_findings)}\n", file=sys.stderr)
        
        # Write output
        if args.output:
            with open(args.output, 'w', encoding='utf-8') as f:
                json.dump(output_data, f, indent=2)
            print(f"Enriched findings written to {args.output}", file=sys.stderr)
        else:
            print(json.dumps(output_data, indent=2))
        
        return 0
    except FileNotFoundError as e:
        print(f"Error: File not found: {e}", file=sys.stderr)
        return 1
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON in input file: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
