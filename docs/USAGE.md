# Usage Guide

This guide covers day-to-day commands and workflows for BazBOM.

## Installation

### Rust CLI (Primary Distribution - Recommended)

BazBOM is transitioning to a memory-safe, single-binary Rust CLI as the primary distribution method. This approach aligns with the project's architecture goals: zero telemetry, offline-first operation, and supply chain security.

**Prerequisites:**
- Rust 1.70+ (stable toolchain)
- Java 11+ (optional, only needed for reachability analysis)

**Build from source:**

```bash
# Clone repository
git clone https://github.com/cboyd0319/BazBOM.git
cd BazBOM

# Build release binary
cargo build --release

# Binary location: ./target/release/bazbom
./target/release/bazbom --version
./target/release/bazbom --help
```

**Basic usage with Rust CLI:**

```bash
# Scan any JVM project (auto-detects Maven, Gradle, Bazel)
./target/release/bazbom scan .

# Scan with specific format
./target/release/bazbom scan . --format spdx
./target/release/bazbom scan . --format cyclonedx

# Enable reachability analysis (requires Java)
./target/release/bazbom scan . --reachability

# Sync advisory database for offline use (zero telemetry)
./target/release/bazbom db sync

# Policy checks
./target/release/bazbom policy check

# Show fix suggestions
./target/release/bazbom fix --suggest
```

**Outputs:**
- `sbom.spdx.json` or `sbom.cyclonedx.json` - SBOM in chosen format
- `sca_findings.json` - Machine-readable vulnerability findings
- `sca_findings.sarif` - GitHub Security format for Code Scanning

## Command Reference

### `bazbom scan` - Generate SBOM and Findings

Generate Software Bill of Materials (SBOM) and perform Software Composition Analysis (SCA).

**Synopsis:**
```bash
bazbom scan [OPTIONS] [PATH]
```

**Arguments:**
- `[PATH]` - Path to project (defaults to current directory `.`)

**Options:**
- `--format <FORMAT>` - Output format: `spdx` (default), `cyclonedx`, or `sarif`
- `--out-dir <DIR>` - Output directory (defaults to current directory `.`)
- `--reachability` - Enable bytecode reachability analysis (requires Java 11+)

**Examples:**

```bash
# Scan current directory with defaults
bazbom scan

# Scan specific project
bazbom scan /path/to/my-java-app

# Generate CycloneDX SBOM
bazbom scan . --format cyclonedx

# Save outputs to reports directory
bazbom scan . --out-dir ./reports

# Perform reachability analysis
bazbom scan . --reachability --out-dir ./reports

# Scan Maven project
cd my-maven-project
bazbom scan .

# Scan Gradle project
cd my-gradle-project
bazbom scan .

# Scan Bazel project (requires maven_install.json)
cd my-bazel-project
bazbom scan .

# For Bazel projects using rules_jvm_external, ensure maven_install.json exists
# If not present, generate it with:
bazel run @maven//:pin
```

**Build System Detection:**

BazBOM automatically detects your build system:
- **Maven**: Looks for `pom.xml`
- **Gradle**: Looks for `build.gradle` or `build.gradle.kts`
- **Bazel**: Looks for `WORKSPACE`, `MODULE.bazel`, or `BUILD.bazel`

**Bazel-Specific Requirements:**

For Bazel projects, BazBOM requires:
1. **maven_install.json**: Generated by rules_jvm_external (run `bazel run @maven//:pin`)
2. Maven dependencies managed via `maven_install()` in WORKSPACE or MODULE.bazel
3. Bazel workspace must be at the project root

**Dependency Extraction:**

BazBOM directly parses `maven_install.json` (no external scripts required) to extract:
- Complete dependency graph with transitive dependencies
- Maven coordinates (group:artifact:version) with full artifact metadata
- SHA256 checksums for all artifacts (integrity verification)
- Dependency relationships (DEPENDS_ON edges for vulnerability impact analysis)
- Repository URLs (provenance tracking)
- Package URLs (PURLs) following the pkg:maven specification

**Supported Bazel Features:**
- ‚úÖ rules_jvm_external (maven_install)
- ‚úÖ WORKSPACE-based configuration
- ‚ö†Ô∏è bzlmod/MODULE.bazel (partial - requires maven_install.json)
- ‚ö†Ô∏è Custom repository rules (not yet supported)

**Performance:**
- Small projects (< 50 deps): < 1 second
- Medium projects (50-200 deps): 1-3 seconds
- Large monorepos (200+ deps): 3-10 seconds

### Bazel-Specific: Selective Target Scanning

**Challenge with Monorepos:** Traditional SCA tools require scanning entire monorepos, which doesn't scale for large Bazel projects (1000+ targets). BazBOM solves this with Bazel-native query support.

#### Scan Specific Targets Using Bazel Query

Use Bazel query expressions to select which targets to scan:

```bash
# Scan only Java binaries in a specific package
bazbom scan . --bazel-targets-query 'kind(java_binary, //src/java/...)'

# Scan all Java targets (binaries + libraries)
bazbom scan . --bazel-targets-query 'kind(java_.*, //...)'

# Scan specific patterns
bazbom scan . --bazel-targets-query 'kind(java_binary, //src/...) + kind(java_library, //lib/...)'

# Complex queries: all tests in a specific area
bazbom scan . --bazel-targets-query 'kind(java_test, //src/java/...) except tests(//src/java/integration/...)'
```

**Real-world example from a monorepo:**
```bash
# Discover all Java binaries
$ bazel query 'kind(java_binary, //src/java/...)'
//src/java:compare_resolvers
//src/java:get_top_x_repos
//src/java:analytics_service

# Scan only those targets
$ bazbom scan . --bazel-targets-query 'kind(java_binary, //src/java/...)'
[bazbom] using Bazel query: kind(java_binary, //src/java/...)
[bazbom] scanning 3 selected targets
  - //src/java:compare_resolvers
  - //src/java:get_top_x_repos
  - //src/java:analytics_service
[bazbom] extracted 247 Bazel components and 312 edges
```

#### Incremental Scanning with `rdeps` (Affected Targets Only)

**The Problem:** In a large monorepo with 1000+ packages, scanning everything on every PR is too slow. Full scan might take 45+ minutes, making it impractical for CI/CD.

**The Solution:** Scan only targets affected by changed files using Bazel's `rdeps()` function.

```bash
# Scan only targets affected by specific file changes
bazbom scan . --bazel-affected-by-files src/java/lib/Utils.java src/java/lib/Helper.java

# Real-world PR workflow: scan targets affected by changes
# 1. Get list of changed files in PR
git diff --name-only origin/main...HEAD > changed_files.txt

# 2. Scan only affected targets
bazbom scan . --bazel-affected-by-files $(cat changed_files.txt)
```

#### Example: Incremental scan on PR

```bash
# Changed file in PR: src/java/main/lib/top_x.java
$ bazbom scan . --bazel-affected-by-files src/java/main/lib/top_x.java

[bazbom] finding targets affected by 1 files
[bazel-query] finding targets affected by 1 files
[bazel-query] found 2 affected targets
[bazbom] scanning 2 selected targets
  - //src/java:get_top_x_repos
  - //src/java:lib

‚è±Ô∏è  Completed in 8.2 seconds (vs 45 minutes for full scan)
üìä 6x faster than full scan
```

**Performance comparison:**

| Scan Type | Targets | Time | Use Case |
|-----------|---------|------|----------|
| Full workspace | 5247 | ~45 min | Main branch, releases |
| Incremental (PR) | 58 (avg) | ~8 min | Pull requests |
| Single package | ~10 | ~2 min | Development |

#### Explicit Target Selection

For maximum control, specify exact targets:

```bash
# Scan specific targets explicitly
bazbom scan . --bazel-targets //src/java:app //src/java:lib //src/common:utils

# Combine with other options
bazbom scan . \
  --bazel-targets //src/java:app //src/java:lib \
  --format spdx \
  --out-dir ./reports
```

#### Universe Control for Large Monorepos

Control the search space for `rdeps` queries:

```bash
# Default: search entire workspace (//...)
bazbom scan . --bazel-affected-by-files file.java

# Restrict to specific subtree (faster for large monorepos)
bazbom scan . \
  --bazel-affected-by-files src/backend/lib/utils.java \
  --bazel-universe '//src/backend/...'

# Multiple packages
bazbom scan . \
  --bazel-affected-by-files common/Config.java \
  --bazel-universe '//src/... + //lib/...'
```

#### CI/CD Integration Example

```yaml
# .github/workflows/pr-scan.yml
name: Incremental Security Scan

on:
  pull_request:
    branches: [main]

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for git diff
      
      - name: Get changed files
        id: changed
        run: |
          # Get files changed in PR
          git diff --name-only origin/main...HEAD > changed_files.txt
          echo "files=$(cat changed_files.txt | tr '\n' ' ')" >> $GITHUB_OUTPUT
      
      - name: Incremental Bazel Scan
        run: |
          # Scan only affected targets
          bazbom scan . \
            --bazel-affected-by-files ${{ steps.changed.outputs.files }} \
            --format spdx \
            --out-dir ./reports
      
      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: reports/sbom.spdx.json
```

#### Best Practices for Bazel Scanning

1. **For PRs**: Always use `--bazel-affected-by-files` with changed files
2. **For releases**: Scan entire workspace (no target filters)
3. **For specific services**: Use `--bazel-targets-query` with service packages
4. **For large monorepos**: Use `--bazel-universe` to restrict search space
5. **Cache results**: Store SBOMs for unchanged targets in CI cache

#### Troubleshooting Bazel Scans

**Query fails:**
```bash
# Validate query syntax first
bazel query 'kind(java_binary, //...)'

# If valid, run with BazBOM
bazbom scan . --bazel-targets-query 'kind(java_binary, //...)'
```

**No targets found:**
```bash
# Check what targets exist
bazel query '//...'

# Check for java targets specifically
bazel query 'kind(java_.*, //...)'
```

**Slow queries:**
```bash
# Use more specific patterns
# Bad: kind(java_.*, //...)
# Good: kind(java_binary, //src/java/...)

# Use --bazel-universe to restrict search space
bazbom scan . \
  --bazel-targets-query 'kind(java_binary, set())' \
  --bazel-universe '//src/...'
```

**Output Files:**

The scan command generates three files:

1. **SBOM File** (`sbom.spdx.json` or `sbom.cyclonedx.json`)
   - Complete dependency inventory
   - License information
   - Package URLs (PURLs)
   - SPDX 2.3 or CycloneDX 1.5 compliant

2. **Findings JSON** (`sca_findings.json`)
   - Machine-readable vulnerability data
   - Enriched with KEV and EPSS metadata
   - Priority scoring (P0-P4) based on CVSS, KEV, and EPSS
   - Severity summary (critical, high, medium, low counts)
   - Structured for automation and CI/CD

3. **SARIF Report** (`sca_findings.sarif`)
   - GitHub Code Scanning compatible format
   - SARIF 2.1.0 standard
   - Integrates with GitHub Security tab
   - Maps severity levels to SARIF levels (error/warning/note)

**Advisory Integration:**

The scan command automatically loads vulnerability data from the local cache (`.bazbom/cache/`) if available. To ensure you have the latest vulnerability data:

```bash
# First, sync the advisory database
bazbom db sync

# Then scan your project
bazbom scan .
```

Each vulnerability in the findings is enriched with:
- **Severity**: CVSS v3/v4 scores (falls back to v2 for legacy CVEs)
- **Priority**: P0-P4 classification based on:
  - P0: Critical (CVSS ‚â•9.0, or KEV with CVSS ‚â•7.0, or EPSS ‚â•0.9)
  - P1: High (CVSS ‚â•7.0 with KEV or EPSS ‚â•0.5)
  - P2: Medium-High (CVSS ‚â•7.0 or CVSS ‚â•4.0 with EPSS ‚â•0.1)
  - P3: Medium (CVSS ‚â•4.0)
  - P4: Low (CVSS <4.0 or unknown)
- **KEV Status**: Whether the vulnerability is in CISA's Known Exploited Vulnerabilities catalog
- **EPSS Score**: Exploit prediction probability (0.0 to 1.0)

### `bazbom db sync` - Sync Advisory Database

Download and cache vulnerability advisory databases for offline use.

**Synopsis:**
```bash
bazbom db sync
```

**Environment Variables:**
- `BAZBOM_OFFLINE=1` - Skip network requests, use placeholders

**Examples:**

```bash
# Download latest advisories
bazbom db sync

# Offline mode (creates placeholder data)
BAZBOM_OFFLINE=1 bazbom db sync
```

**Data Sources:**

BazBOM syncs from multiple authoritative sources:
- **OSV** (Open Source Vulnerabilities) - Cross-ecosystem database
- **NVD** (National Vulnerability Database) - NIST-maintained CVE database
- **GHSA** (GitHub Security Advisories) - GitHub's vulnerability database
- **CISA KEV** (Known Exploited Vulnerabilities) - Actively exploited CVEs
- **EPSS** (Exploit Prediction Scoring System) - Exploit likelihood scores

**Cache Location:**
- Default: `.bazbom/cache/`
- Contains: `advisories/` directory with JSON/CSV files
- Manifest: `manifest.json` with file hashes and timestamps

**Offline Operation:**

After syncing, you can work offline:
```bash
# Sync when online
bazbom db sync

# Later, work offline
BAZBOM_OFFLINE=1 bazbom scan .
```

### `bazbom policy check` - Apply Policy Checks

Run policy checks against generated findings.

**Synopsis:**
```bash
bazbom policy check
```

**Configuration:**

Create a `bazbom.yml` file in your project root (optional):

```yaml
severity_threshold: HIGH
kev_gate: true
epss_threshold: 0.5
reachability_required: false
vex_auto_apply: true
license_allowlist:
  - MIT
  - Apache-2.0
  - BSD-3-Clause
license_denylist:
  - GPL-3.0
  - AGPL-3.0
```

**Examples:**

```bash
# Run policy checks
bazbom policy check

# Typical workflow
bazbom scan .
bazbom policy check
```

**Policy Rules:**

- `severity_threshold` - Block vulnerabilities at or above severity level (NONE, LOW, MEDIUM, HIGH, CRITICAL)
- `kev_gate` - Block any vulnerability in CISA's Known Exploited Vulnerabilities list
- `epss_threshold` - Block vulnerabilities with EPSS score above threshold (0.0 to 1.0)
- `license_allowlist` - Only allow specified licenses
- `license_denylist` - Block specified licenses
- `reachability_required` - Require reachability analysis (future capability)
- `vex_auto_apply` - Auto-generate VEX for unreachable vulnerabilities (future capability)

**Output Files:**

When you run `bazbom policy check`, two files are generated:

1. **Policy Result** (`policy_result.json`)
   - Machine-readable pass/fail result
   - List of all policy violations
   - Includes vulnerability details for each violation

2. **SARIF Report** (`policy_violations.sarif`)
   - GitHub Security compatible format
   - Violations mapped to SARIF levels
   - Upload to GitHub Code Scanning for PR annotations

**Exit Codes:**

- `0` - All policy checks passed
- `1` - One or more policy violations found

**Policy Integration with Scan:**

The `scan` command automatically applies policy checks if a `bazbom.yml` file exists:

```bash
# Create policy configuration
cat > bazbom.yml << EOF
severity_threshold: HIGH
kev_gate: true
epss_threshold: 0.5
EOF

# Run scan - policy checks applied automatically
bazbom scan .
```

When policy violations are detected during scan:
- Violations are printed to console
- Additional file `policy_violations.json` is created in output directory
- Exit code remains 0 (scan completes, policy check is informational)

To enforce policy violations in CI, use `bazbom policy check` as a separate step:

```bash
# First, generate SBOM and findings
bazbom scan .

# Then, enforce policy (exits non-zero on violations)
bazbom policy check
```

**Example Policy Configurations:**

BazBOM includes three example policy configurations in the `examples/` directory:

- `bazbom.yml` - Balanced policy for most projects
- `bazbom-strict.yml` - Strict policy for critical systems
- `bazbom-permissive.yml` - Permissive policy for development

Copy one to your project root and customize as needed:

```bash
cp examples/bazbom-strict.yml bazbom.yml
```

### `bazbom fix` - Remediation Suggestions

Suggest or apply dependency fixes.

**Synopsis:**
```bash
bazbom fix [OPTIONS]
```

**Options:**
- `--suggest` - Show fix suggestions without applying changes (recommend-only)
- `--apply` - Apply fixes and open pull requests (when implemented)

**Examples:**

```bash
# Get fix suggestions
bazbom fix --suggest

# Apply fixes (future capability)
bazbom fix --apply
```

**Suggest Mode (Default):**
- Shows recommended dependency upgrades
- Explains why each fix matters
- Educational context about vulnerabilities
- Safe, non-invasive

**Apply Mode (Roadmap):**
- Automatically updates dependency files
- Runs tests to verify compatibility
- Opens pull request with changes
- Includes rollback capability

### Advanced: Reachability Analysis

**Bytecode reachability analysis** helps reduce false positives by identifying which vulnerable code paths are actually reachable from your application's entry points.

**Setup:**

First, build the reachability analyzer:

```bash
cd tools/reachability
mvn clean package
```

This creates `target/bazbom-reachability-0.1.0-SNAPSHOT.jar` (~690KB).

**Usage:**

```bash
# Set environment variable
export BAZBOM_REACHABILITY_JAR=/path/to/BazBOM/tools/reachability/target/bazbom-reachability-0.1.0-SNAPSHOT.jar

# Run scan with reachability analysis
bazbom scan . --reachability --out-dir ./reports
```

**What it Does:**

1. **Extracts classpath** from your build system (Maven, Gradle, or Bazel)
2. **Analyzes bytecode** using ASM library to build call graphs
3. **Detects entry points** (main methods, public constructors)
4. **Tags vulnerabilities** as `[REACHABLE]` or `[NOT REACHABLE]` in SARIF output
5. **Caches results** (Blake3 hashing) for fast subsequent runs

**Performance:**
- Small projects (<100 classes): <1 second
- Medium projects (100-1000 classes): 1-5 seconds  
- Large projects (1000+ classes): 5-30 seconds
- **Cache hit**: ~1ms (99% faster on unchanged code)

**Example Output:**

```bash
[bazbom] running reachability analysis
[bazbom] jar: "/path/to/bazbom-reachability.jar"
[bazbom] classpath entries: 47
[bazbom] reachability complete:
  - detected entrypoints: 12
  - reachable methods: 1,243
  - reachable classes: 287
  - reachable packages: 53
```

**SARIF Integration:**

Reachability results are automatically included in `sca_findings.sarif`:

```json
{
  "message": {
    "text": "[NOT REACHABLE] CVE-2023-12345: Remote Code Execution in org.apache.commons:commons-text:1.9"
  }
}
```

**Cache Behavior:**

Reachability results are cached in `.bazbom/cache/reachability/` based on:
- Classpath content (all JAR files)
- Entry points configuration
- Blake3 hash for integrity

Cache is automatically invalidated when:
- Dependencies change
- Entry points change
- Class files are recompiled

**Policy Integration:**

Reachability-aware policy checks can be configured in `bazbom.yml`:

```yaml
policy:
  severity_threshold: HIGH
  ignore_unreachable: true  # Skip NOT REACHABLE findings
```

**Limitations:**

- **Dynamic dispatch**: Conservative analysis includes all potential targets
- **Reflection**: Methods invoked via reflection are not tracked
- **Native code**: JNI calls are not analyzed
- **Dynamic class loading**: Runtime-loaded classes not included

### Advanced: Shading and Relocation Detection

**Fat JAR and shaded dependency analysis** identifies and maps relocated classes back to their original artifacts, enabling accurate vulnerability attribution.

**What Are Shaded JARs?**

Shading (also called "fat JAR" or "uber JAR") is a technique that:
1. Bundles all dependencies into a single JAR
2. Relocates packages to avoid conflicts (e.g., `org.apache` ‚Üí `myapp.shaded.org.apache`)

Popular plugins:
- Maven: `maven-shade-plugin`
- Gradle: `com.github.johnrengelman.shadow`

**Detection:**

BazBOM automatically detects shading configurations:

```bash
# Maven projects: reads pom.xml for maven-shade-plugin
bazbom scan my-maven-app/

# Gradle projects: reads build.gradle[.kts] for shadow plugin
bazbom scan my-gradle-app/
```

**Configuration Parsing:**

BazBOM uses proper XML parsing for Maven and pattern matching for Gradle to extract relocation mappings.

**Maven Shade (pom.xml):**
```xml
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-shade-plugin</artifactId>
  <configuration>
    <finalName>my-shaded-app</finalName>
    <relocations>
      <relocation>
        <pattern>org.apache.commons</pattern>
        <shadedPattern>myapp.shaded.commons</shadedPattern>
        <includes>
          <include>org.apache.commons.lang3.**</include>
        </includes>
        <excludes>
          <exclude>org.apache.commons.logging.**</exclude>
        </excludes>
      </relocation>
    </relocations>
  </configuration>
</plugin>
```

Supports:
- Multiple `<relocation>` blocks
- Include/exclude patterns
- `<finalName>` configuration
- Nested configurations

**Gradle Shadow (build.gradle.kts):**
```kotlin
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar

plugins {
    id("com.github.johnrengelman.shadow") version "8.1.1"
}

tasks.withType<ShadowJar> {
    relocate("org.apache", "myapp.shaded.org.apache")
    relocate("com.google.common", "myapp.shaded.guava")
}
```

**Relocation Mapping:**

BazBOM builds reverse mapping tables:

```
Shaded Class                        ‚Üí Original Class
myapp.shaded.org.apache.commons.Lang ‚Üí org.apache.commons.Lang
myapp.shaded.guava.collect.Lists     ‚Üí com.google.common.collect.Lists
```

**Class Fingerprinting:**

For ambiguous cases, BazBOM uses bytecode fingerprinting:
- **Blake3 hash** of class bytecode
- **Method signatures** (name + parameter types)
- **Field signatures** (name + type)
- **Confidence scoring** (0.0-1.0)

**Vulnerability Attribution:**

Findings are mapped to original artifacts:

```json
{
  "shadedClass": "myapp.shaded.org.apache.commons.text.StringEscapeUtils",
  "originalClass": "org.apache.commons.text.StringEscapeUtils",
  "originalArtifact": "org.apache.commons:commons-text:1.9",
  "vulnerability": "CVE-2022-42889",
  "confidence": 1.0
}
```

**SARIF Output:**

```json
{
  "message": {
    "text": "CVE-2022-42889 in shaded class myapp.shaded.org.apache.commons.text.* (original: org.apache.commons:commons-text:1.9)"
  }
}
```

**Best Practices:**

1. **Document relocations**: Keep shading configs up-to-date
2. **Minimize shading**: Only relocate conflicting packages
3. **Version tracking**: Use `finalName` to embed version info
4. **Test coverage**: Ensure shaded code has adequate tests

**Implementation Status:**

‚úÖ **Implemented:**
- Maven Shade plugin XML parsing (using quick-xml parser)
- Nested JAR extraction from fat JARs (using zip library)
- Class fingerprinting with Blake3 bytecode hashing
- Relocation pattern matching and reverse mapping
- Include/exclude pattern support
- Multiple relocation mapping support

üîÑ **In Progress:**
- Gradle Shadow plugin DSL parsing (basic pattern matching works)
- Detailed method/field signature extraction (currently uses bytecode hash only)
- Integration with scan command output (coming soon)

**Requirements:**
- Build files must be present (pom.xml or build.gradle[.kts])
- For detailed analysis, JAR files should be built first

### Environment Variables

**General:**
- `BAZBOM_OFFLINE=1` - Enable offline mode (no network calls)

**Reachability:**
- `BAZBOM_REACHABILITY_JAR=/path/to/reachability.jar` - Path to reachability analyzer JAR

**Examples:**

```bash
# Offline operation
BAZBOM_OFFLINE=1 bazbom db sync
BAZBOM_OFFLINE=1 bazbom scan .

# Custom reachability JAR
BAZBOM_REACHABILITY_JAR=/custom/path/analyzer.jar bazbom scan . --reachability
```

### Python CLI Wrapper (Transition Phase)

### Quick Install (Recommended)

Install BazBOM with zero configuration:

```bash
# Recommended: Download and inspect first (safest)
curl -fsSL https://raw.githubusercontent.com/cboyd0319/BazBOM/main/install.sh -o install.sh
cat install.sh  # Review the script
bash install.sh

# Alternative: One-line install (if you trust the source)
curl -fsSL https://raw.githubusercontent.com/cboyd0319/BazBOM/main/install.sh | bash

# Or download and run locally
wget https://raw.githubusercontent.com/cboyd0319/BazBOM/main/install.sh
chmod +x install.sh
./install.sh
```

**‚ö†Ô∏è Security Note**: Always review scripts before running them, especially when using pipe-to-bash (`| bash`). The recommended approach is to download, inspect, and then execute.

The installer will:
- ‚úÖ Detect your platform (Linux/macOS, amd64/arm64)
- ‚úÖ Check prerequisites (Python 3, Git)
- ‚úÖ Check for RipGrep (optional, enables 100x faster scanning)
- ‚úÖ Install BazBOM to `~/.bazbom`
- ‚úÖ Add `bazbom` command to your PATH
- ‚úÖ Auto-configure Bazel projects (if detected)

### Optional: Install RipGrep for 100x Faster Scanning

RipGrep dramatically accelerates dependency discovery, license scanning, and incremental analysis. **Highly recommended for large monorepos (1000+ files).**

```bash
# Debian/Ubuntu
sudo apt install ripgrep

# RHEL/CentOS
sudo yum install ripgrep

# macOS
brew install ripgrep

# Verify installation
rg --version
```

**Performance impact:**
- Find BUILD files: **136x faster** (12.3s ‚Üí 0.09s)
- License header scan (10K files): **18.9x faster** (34s ‚Üí 1.8s)
- Incremental PR analysis: **6.25x faster** (45s ‚Üí 7.2s)

See [RIPGREP_INTEGRATION.md](RIPGREP_INTEGRATION.md) for detailed benchmarks.

### Manual Installation

```bash
# Clone repository
git clone https://github.com/cboyd0319/BazBOM.git ~/.bazbom

# Add to PATH
echo 'export PATH="$HOME/.bazbom:$PATH"' >> ~/.bashrc
source ~/.bashrc

# Verify installation
bazbom version
```

## Quick Start with BazBOM CLI

BazBOM includes a unified CLI that works with **any JVM project**, not just Bazel:

```bash
# Scan any JVM project (auto-detects Maven, Gradle, or Bazel)
bazbom scan .

# Watch for changes and re-scan automatically
bazbom scan --watch

# Initialize configuration file (bazbom.yml)
bazbom init

# Show version
bazbom version
```

## RipGrep-Accelerated Commands

BazBOM leverages [RipGrep](https://github.com/BurntSushi/ripgrep) for 100-1000x faster scanning in large monorepos. All commands automatically detect RipGrep and enable acceleration when available.

### Fast Dependency Discovery

```bash
# Scan with automatic RipGrep acceleration (if installed)
bazbom scan . --fast-discovery

# Force standard mode (disable RipGrep)
bazbom scan . --no-fast-discovery
```

**Performance:** 5000-target monorepo analyzed in **8 seconds** vs **45 seconds** without RipGrep (5.6x speedup).

### License Compliance Scanning

Scan 10,000+ source files for license headers in ~2 seconds:

```bash
# Generate full license compliance report (CSV format)
bazbom license-report --output licenses.csv

# Generate JSON format report
bazbom license-report --output licenses.json --format json

# Check for copyleft licenses (GPL, LGPL) - exits with error if found
bazbom license-report --check-copyleft

# Find files without license headers
bazbom license-report --find-unlicensed

# Show detailed file listings
bazbom license-report --verbose
```

**Example output:**
```
Scanned 2,547 source files
  Licensed: 2,489
  Unlicensed: 58

License distribution:
  Apache-2.0: 1,823 files
  MIT: 512 files
  Proprietary: 154 files
  GPL-3.0: 0 files

‚úÖ License report saved to: licenses.csv
```

### Container Image Scanning

Fast JAR and OS package discovery in container images:

```bash
# Scan container image (requires Docker or Podman)
bazbom scan-container myapp:latest --output container-sbom.json

# Scan already-extracted layers (skip extraction)
bazbom scan-container --layers-path /tmp/extracted-image --output sbom.json
```

**Performance:** 10.9x faster than traditional 'find' for multi-GB images.

**Example output:**
```
Extracting myapp:latest layers...
Scanning for JAR files...
Scanning for OS packages...

‚úÖ Scan complete:
  JAR files found: 127
  OS package systems: dpkg, apk

SBOM saved to: container-sbom.json
```

### Dependency Verification

Detect unused or undeclared dependencies:

```bash
# Full dependency usage report
bazbom verify

# Check for unused dependencies (exits with error if found)
bazbom verify --check-unused

# Check for undeclared dependencies (missing from maven_install.json)
bazbom verify --check-undeclared

# Use custom maven_install.json path
bazbom verify --maven-install-json path/to/maven_install.json

# Save report to JSON
bazbom verify --output usage-report.json
```

**Example output:**
```
Verifying dependencies in: /workspace
Using lockfile: maven_install.json

Dependency Usage Report:
  Declared dependencies: 347
  Referenced dependencies: 298
  Used dependencies: 298
  Unused dependencies: 49
  Undeclared dependencies: 0
  Dependency usage rate: 85.9%

‚ö†Ô∏è  49 unused dependencies found
```

### CVE Reference Tracking

Find CVE references in code, comments, and VEX statements:

```bash
# Find all CVE references in codebase
bazbom find-cves --output cves.json

# Cross-reference with SBOM findings
bazbom find-cves --sbom-findings sca_findings.json --output cve-cross-ref.json

# Find VEX statements with CVE references
bazbom find-cves --find-vex

# Show detailed CVE listings
bazbom find-cves --verbose
```

**Example output:**
```
Searching for CVE references in: /workspace

Found 42 CVE references (28 unique CVEs)

Cross-reference with SBOM findings:
  In both code and SBOM: 15
  Documented only (code): 13
  SBOM only (not in SBOM): 0

Report saved to: cves.json
```

### Watch Mode for Development

Continuously monitor for changes and re-scan automatically:

```bash
# Watch current directory with BazBOM CLI
bazbom scan --watch

# Watch with custom workspace using the watch script
./tools/watch-dependencies.sh --workspace /path/to/project

# Use custom scan command
./tools/watch-dependencies.sh --command "bazel build //:sbom_all"
```

**Requires:**
- `ripgrep` - Fast file finding
- `entr` - File watching utility

**Installation:**
```bash
# Debian/Ubuntu
sudo apt install ripgrep entr

# macOS
brew install ripgrep entr
```

### Using via Bazel (Alternative)

If you prefer using Bazel directly:

```bash
# Scan any JVM project (auto-detects Maven, Gradle, or Bazel)
bazel run //tools/supplychain:bazbom_cli -- scan .

# Initialize configuration file (bazbom.yml)
bazel run //tools/supplychain:bazbom_cli -- init

# Show version
bazel run //tools/supplychain:bazbom_cli -- version
```

### Supported Build Systems

BazBOM automatically detects and works with:
- **Maven** (pom.xml)
- **Gradle** (build.gradle, build.gradle.kts)
- **Bazel** (WORKSPACE, MODULE.bazel)

### Configuration File (bazbom.yml)

Create a `bazbom.yml` in your project root to customize behavior:

```yaml
# Build system (auto-detect by default)
build_system: auto  # or: maven, gradle, bazel

# Include test dependencies in scans
include_test_deps: false

# Output formats
output_formats:
  - spdx
  - cyclonedx

# Minimum severity to report
severity_threshold: MEDIUM  # CRITICAL, HIGH, MEDIUM, LOW

# Policy enforcement
policy:
  block_critical: true
  fail_on_policy_violation: true
  max_critical: 0
  max_high: 10

# Vulnerability sources
vulnerability_sources:
  osv:
    enabled: true
  nvd:
    enabled: false

# Output file paths
output:
  sbom_path: sbom.spdx.json
  findings_path: sca_findings.json
  sarif_path: sca_findings.sarif
```

### CSV Export

Export scan results to CSV for analysis in spreadsheet tools:

```bash
# Export SBOM to CSV
bazel build //:sbom_csv
cat bazel-bin/workspace_sbom.csv

# Export vulnerabilities to CSV
bazel build //:vulnerabilities_csv
cat bazel-bin/vulnerabilities.csv

# Export license report to CSV
bazel build //:licenses_csv
cat bazel-bin/licenses.csv
```

### Security Badges

Generate shields.io compatible badges for your README:

```bash
# Generate badge JSON
bazel build //:security_badge
cat bazel-bin/security_badge.json

# Use in GitHub workflows to update README badge
# Badge color: green (no vulns), yellow (medium), orange (high), red (critical)
```

### Watch Mode

Continuously monitor your project and re-scan on changes:

```bash
# Watch mode - re-scans when build files change
bazbom scan --watch

# What it monitors:
# - Maven: pom.xml files
# - Gradle: build.gradle, build.gradle.kts, settings.gradle
# - Bazel: WORKSPACE, BUILD files, *.bzl files

# Press Ctrl+C to stop watching
```

**Use Cases for Watch Mode:**
- **Development**: Get real-time feedback as you update dependencies
- **CI/CD**: Monitor long-running builds for dependency changes
- **Security**: Immediate alerts when new vulnerabilities are introduced

## GitHub Action Integration

Add automated security scanning to your GitHub workflows:

### Basic Setup

Create `.github/workflows/security.yml`:

```yaml
name: Supply Chain Security

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  scan:
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      security-events: write
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Run BazBOM Security Scan
        uses: cboyd0319/BazBOM@main
        with:
          fail-on-critical: true
          upload-sbom: true
          upload-sarif: true
```

### Advanced Configuration

```yaml
- name: Run BazBOM Security Scan
  uses: cboyd0319/BazBOM@main
  with:
    # Build system (auto-detect by default)
    build-system: auto  # or: maven, gradle, bazel
    
    # Project path
    path: .
    
    # Policy enforcement
    fail-on-critical: true
    fail-on-high: false
    max-critical: 0
    max-high: 10
    
    # Dependencies
    include-test-deps: false
    
    # Outputs
    upload-sbom: true
    upload-sarif: true
    output-format: spdx  # or: cyclonedx, both
    
    # Custom policy
    policy-file: .bazbom/policy.yml
```

### Action Outputs

Access scan results in subsequent steps:

```yaml
- name: Run BazBOM Security Scan
  id: scan
  uses: cboyd0319/BazBOM@main

- name: Check Results
  run: |
    echo "Vulnerabilities found: ${{ steps.scan.outputs.vulnerabilities-found }}"
    echo "Critical count: ${{ steps.scan.outputs.critical-count }}"
    echo "High count: ${{ steps.scan.outputs.high-count }}"
    echo "SBOM path: ${{ steps.scan.outputs.sbom-path }}"
```

### PR Comments

The action automatically comments on pull requests with scan results:

```markdown
## üî¥ BazBOM Security Scan Results

**Status:** 2 CRITICAL vulnerabilities found

### üî¥ Critical Issues (2)
Review the SARIF report for details.

**Total vulnerabilities:** 5
- CRITICAL: 2
- HIGH: 3

üìä View detailed findings in the Security tab
```

## Container Image SBOM Scanning

Generate SBOMs for container images, including application dependencies and OS packages:

### Basic Usage

```bash
# Scan local Docker image
bazel run //tools/supplychain:scan_container -- myapp:latest

# Scan image from registry
bazel run //tools/supplychain:scan_container -- registry.io/myapp:v1.2.3

# Output to file
bazel run //tools/supplychain:scan_container -- myapp:latest --output sbom.json

# CycloneDX format
bazel run //tools/supplychain:scan_container -- myapp:latest --format cyclonedx
```

### What Gets Scanned

The container scanner analyzes:
- **Application dependencies**: JAR files and their metadata
- **OS packages**: Packages installed via apt, yum, or apk
- **Base image layers**: All container layers
- **Image metadata**: Architecture, OS, creation date

### Integration with Docker/Podman

Works with both Docker and Podman:

```bash
# Using Docker
docker pull myapp:latest
bazel run //tools/supplychain:scan_container -- myapp:latest

# Using Podman
podman pull myapp:latest
bazel run //tools/supplychain:scan_container -- myapp:latest
```

### Dockerfile Integration

Embed SBOM generation in your Dockerfile:

```dockerfile
FROM openjdk:11-jre-slim

COPY target/app.jar /app/app.jar

# Generate SBOM during build (requires BazBOM installed)
RUN bazbom scan-container --output /app/sbom.spdx.json

# Attach SBOM as OCI artifact
LABEL org.opencontainers.image.sbom=/app/sbom.spdx.json
```

## Interactive Vulnerability Fix

Automatically generate and apply fixes for vulnerable dependencies:

### Basic Usage

```bash
# Interactive mode - prompts for each fix
bazel run //tools/supplychain:interactive_fix -- \
  --findings bazel-bin/sca_findings.json

# Specify project directory
bazel run //tools/supplychain:interactive_fix -- \
  --findings sca_findings.json \
  --project /path/to/project
```

### How It Works

1. **Analyzes vulnerabilities**: Identifies which can be fixed by upgrading
2. **Generates fixes**: Creates build-system-specific overrides
3. **Interactive prompts**: Shows details and asks for confirmation
4. **Applies fixes**: Updates build files (pom.xml, build.gradle, WORKSPACE)

### Example Session

```
üîç Found 3 fixable vulnerabilities

Build system: maven
============================================================

Fix 1/3
------------------------------------------------------------
Package: com.fasterxml.jackson.core:jackson-databind
Current version: 2.13.0
Recommended version: 2.13.4.2
Severity: CRITICAL
CVE: CVE-2022-42003

Generated fix:

<!-- BazBOM auto-generated fix -->
<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-databind</artifactId>
  <version>2.13.4.2</version>
</dependency>

Apply fix? [y/N/skip all] y
‚úÖ Fix queued for application

...

============================================================
Applying 2 fixes...
============================================================
‚úì Updated pom.xml

‚úÖ Successfully applied 2 fixes

Next steps:
  1. Review changes in pom.xml
  2. Run: mvn clean install
  3. Run tests to verify compatibility
```

### Supported Build Systems

**Maven**: Generates `<dependencyManagement>` overrides
```xml
<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>com.example</groupId>
      <artifactId>vulnerable-dep</artifactId>
      <version>2.1</version>
    </dependency>
  </dependencies>
</dependencyManagement>
```

**Gradle**: Generates `resolutionStrategy` force overrides
```kotlin
configurations.all {
    resolutionStrategy {
        force('com.example:vulnerable-dep:2.1')
    }
}
```

**Bazel**: Provides instructions for `maven_install.json` updates
```python
# Add to maven_install() in WORKSPACE:
override_targets = {
    "com.example:vulnerable-dep": "@maven//:com_example_vulnerable_dep",
},
```

## Dependency Extraction

BazBOM uses **maven_install.json** as the source of truth for Maven dependencies, as recommended by the Bazel ecosystem. This lockfile provides:

- Complete transitive dependency graph
- Exact versions for all dependencies
- SHA256 checksums for verification
- Dependency relationship mapping

### Automatic Dependency Extraction

```bash
# Extract all dependencies (prefers maven_install.json if available)
bazel build //:extract_deps

# View extracted dependencies
cat bazel-bin/workspace_deps.json | jq
```

**Output includes:**
- Direct dependencies (declared in WORKSPACE)
- Transitive dependencies (from maven_install.json)
- SHA256 checksums for all artifacts
- Package URLs (PURLs) for each dependency

### Manual Extraction

```bash
# Extract from maven_install.json
python tools/supplychain/extract_maven_deps.py \
  --workspace WORKSPACE \
  --maven-install-json maven_install.json \
  --output deps.json

# Extract from WORKSPACE only (fallback)
python tools/supplychain/extract_maven_deps.py \
  --workspace WORKSPACE \
  --output deps.json \
  --prefer-lockfile=false
```

## SBOM Generation

### Generate SBOM for a Single Target

```bash
bazel build //path/to:target.sbom
```

### Generate SBOMs for All Targets

```bash
# Generate SPDX 2.3 SBOMs (default)
bazel build //:sbom_all

# Generate both SPDX and CycloneDX formats
bazel build //:sbom_all_formats
```

**The SBOM now includes:**
- All transitive dependencies (not just direct deps)
- SHA256 checksums for verification
- Proper dependency relationships (e.g., Guava ‚Üí failureaccess)
- Package URLs (PURLs) for each artifact

### Generate CycloneDX SBOM

BazBOM supports CycloneDX 1.5 format in addition to SPDX 2.3:

```bash
# Generate CycloneDX SBOM for workspace
bazel build //:workspace_sbom_cyclonedx

# View the CycloneDX SBOM
cat bazel-bin/workspace_sbom.cdx.json | jq

# Generate custom CycloneDX SBOM
python tools/supplychain/write_sbom.py \
  --input workspace_deps.json \
  --output sbom.cdx.json \
  --format cyclonedx \
  --name my-application
```

**CycloneDX format includes:**
- Components with PURLs and hashes
- License information (SPDX IDs)
- External references (download URLs)
- Dependency relationships
- Metadata (tools, timestamp)

### SBOM Format Comparison

| Feature | SPDX 2.3 | CycloneDX 1.5 |
|---------|----------|---------------|
| Format | JSON | JSON |
| Spec Version | 2.3 | 1.5 |
| Relationships | Explicit | Dependency graph |
| License IDs | SPDX IDs | SPDX IDs |
| Tool Support | Wide | Wide |
| Use Case | Compliance, legal | Security, DevSecOps |

**When to use each:**
- **SPDX**: Legal compliance, license analysis, regulatory requirements
- **CycloneDX**: Security scanning, vulnerability management, DevSecOps workflows

### Generate SBOM with Custom Options

```bash
bazel build //path/to:target.sbom \
  --@bazbom//config:sbom_format=spdx-2.3 \
  --@bazbom//config:include_transitive=true
```

## SBOM Diffing & Change Tracking

BazBOM can compare SBOMs to identify changes between releases, detect drift, and generate automated release notes.

### Compare Two SBOMs

```bash
# Compare two SBOMs to see what changed
bazel run //tools/supplychain:sbom_diff -- \
  bazel-bin/v1.0.0_sbom.spdx.json \
  bazel-bin/v1.1.0_sbom.spdx.json

# Generate JSON output for automation
bazel run //tools/supplychain:sbom_diff -- \
  baseline.json current.json \
  --format json > diff.json

# Save human-readable report
bazel run //tools/supplychain:sbom_diff -- \
  old.json new.json \
  --format text -o DIFF_REPORT.txt
```

**Output includes:**
- New dependencies added
- Dependencies removed
- Dependencies upgraded/downgraded
- License changes
- Summary statistics

**Example output:**
```
üì¶ SBOM DIFF REPORT
================================================================================

Comparing:
  Old: my-app-v1.0.0
  New: my-app-v1.1.0

Summary:
  Total packages (old):  150
  Total packages (new):  152
  Added:                 3
  Removed:               1
  Upgraded:              5
  Downgraded:            0
  License changed:       1

NEW DEPENDENCIES (3):
  + io.grpc:grpc-netty@1.50.0 (Apache-2.0)
  + org.bouncycastle:bcprov-jdk15on@1.70 (MIT)
  + io.netty:netty-handler@4.1.90 (Apache-2.0)

UPGRADED DEPENDENCIES (5):
  ‚Üë com.google.guava:guava: 30.1-jre ‚Üí 31.1-jre
  ‚Üë org.slf4j:slf4j-api: 1.7.32 ‚Üí 2.0.0
```

### Drift Detection

Detect unexpected changes against a baseline SBOM:

```bash
# Check for drift against baseline
bazel run //tools/supplychain:drift_detector -- \
  baseline.json current.json

# Output JSON for automation
bazel run //tools/supplychain:drift_detector -- \
  baseline.json current.json \
  --format json

# Fail build on warnings (strict mode)
bazel run //tools/supplychain:drift_detector -- \
  baseline.json current.json \
  --strict
```

**Built-in drift rules:**
- **DRIFT-001**: Unexpected dependency additions (threshold: 5)
- **DRIFT-002**: Unexpected dependency removals (threshold: 3)
- **DRIFT-003**: License changes to forbidden licenses (GPL, AGPL)
- **DRIFT-004**: Version downgrades detected

**Example output:**
```
‚ö†Ô∏è  STATUS: WARNING (non-critical issues found)

Summary:
  Total violations:  2
  Critical:          0
  Error:             0
  Warning:           2

DRIFT VIOLATIONS:
‚ö†Ô∏è [WARNING] DRIFT-001: Unexpected Dependency Additions
   Found 7 new dependencies (threshold: 5)

‚ö†Ô∏è [WARNING] DRIFT-003: License Changes Detected
   org.apache.commons:commons-text@1.9
      Apache-2.0 ‚Üí GPL-3.0
```

### Generate Release Notes

Automatically generate release notes from SBOM changes:

```bash
# Generate markdown release notes
bazel run //tools/supplychain:changelog_generator -- \
  v1.0.0.spdx.json v1.1.0.spdx.json \
  --format markdown \
  --old-version v1.0.0 \
  --new-version v1.1.0 \
  -o CHANGELOG.md

# Generate HTML changelog
bazel run //tools/supplychain:changelog_generator -- \
  old.json new.json \
  --format html \
  -o release-notes.html

# Generate plain text
bazel run //tools/supplychain:changelog_generator -- \
  baseline.json current.json \
  --format text
```

**Markdown output example:**
```markdown
# Release Notes: v1.0.0 ‚Üí v1.1.0

## üìä Summary

| Metric | Count |
|--------|-------|
| Total Dependencies (old) | 150 |
| Total Dependencies (new) | 152 |
| ‚ûï Added | 3 |
| ‚ûñ Removed | 1 |
| ‚¨ÜÔ∏è Upgraded | 5 |
| ‚¨áÔ∏è Downgraded | 0 |

## ‚ûï New Dependencies (3)

- **io.grpc:grpc-netty** `1.50.0`
  - License: `Apache-2.0`
  - PURL: `pkg:maven/io.grpc/grpc-netty@1.50.0`

## ‚¨ÜÔ∏è Upgraded Dependencies (5)

- **com.google.guava:guava**: `30.1-jre` ‚Üí `31.1-jre`
- **org.slf4j:slf4j-api**: `1.7.32` ‚Üí `2.0.0`
```

### Use Cases

**1. Pre-merge checks:**
```bash
# Detect unexpected changes before merging PR
git show main:bazel-bin/workspace_sbom.spdx.json > baseline.json
bazel build //:workspace_sbom
bazel run //tools/supplychain:drift_detector -- \
  baseline.json bazel-bin/workspace_sbom.spdx.json \
  --strict
```

**2. Release documentation:**
```bash
# Generate release notes automatically
bazel run //tools/supplychain:changelog_generator -- \
  releases/v1.0.0.json bazel-bin/workspace_sbom.spdx.json \
  --old-version v1.0.0 \
  --new-version v1.1.0 \
  --format markdown \
  -o RELEASE_NOTES.md
```

**3. Security impact analysis:**
```bash
# Compare SBOMs to identify security changes
bazel run //tools/supplychain:sbom_diff -- \
  baseline.json current.json \
  --format json | \
  jq '.changes.upgraded[] | select(.name | contains("log4j"))'
```

## Vulnerability Scanning

### Scan Single SBOM

```bash
bazel run //tools/supplychain:osv_query -- \
  --sbom bazel-bin/path/to/package.spdx.json \
  --output bazel-bin/path/to/vulnerabilities.sarif.json
```

### Scan All Generated SBOMs

```bash
bazel run //:sca_from_sbom
```

This automatically discovers all `.spdx.json` files and queries OSV.

### Custom OSV Query

```bash
python tools/supplychain/osv_query.py \
  --sbom path/to/sbom.json \
  --output vulnerabilities.json \
  --batch
```

### Vulnerability Enrichment

BazBOM enriches vulnerability findings with multiple authoritative data sources to provide actionable prioritization:

#### Enrichment Data Sources

1. **CISA KEV (Known Exploited Vulnerabilities)** - CVEs actively exploited in the wild
2. **EPSS (Exploit Prediction Scoring)** - ML-based exploitation probability (0-100%)
3. **GitHub Security Advisories (GHSA)** - Ecosystem-specific remediation guidance
4. **VulnCheck KEV** (optional) - Advanced exploit intelligence with API key

#### Enable Enrichment (Default)

```bash
# Enrichment is enabled by default
bazel run //tools/supplychain:osv_query -- \
  --sbom bazel-bin/workspace.spdx.json \
  --output bazel-bin/vulnerabilities_enriched.json
```

#### Enrichment Output

Enriched findings include:

- **Risk Score (0-100)**: Composite score combining CVSS, EPSS, KEV, and exploit data
- **Priority (P0-P4)**: Actionable priority levels
  - **P0-IMMEDIATE**: In CISA KEV (fix now)
  - **P1-CRITICAL**: Risk score ‚â• 80
  - **P2-HIGH**: Risk score ‚â• 60
  - **P3-MEDIUM**: Risk score ‚â• 40
  - **P4-LOW**: Risk score < 40
- **KEV Status**: Whether CVE is being actively exploited
- **EPSS Score**: Exploitation probability percentage
- **Exploit Intelligence**: Weaponization status, attack vector
- **GHSA Remediation**: Patched versions, vulnerable ranges

#### Priority Summary

```bash
üìä Priority Summary:
  üö® P0 - IMMEDIATE (KEV):     2  ‚Üê FIX NOW
  üî¥ P1 - CRITICAL:            5  ‚Üê This week
  üü† P2 - HIGH:                8  ‚Üê This sprint
  üü° P3 - MEDIUM:              6  ‚Üê Next quarter
  üü¢ P4 - LOW:                 2  ‚Üê Backlog
```

#### Advanced Enrichment Options

```bash
# With GitHub token for higher GHSA rate limits
bazel run //tools/supplychain:osv_query -- \
  --sbom bazel-bin/workspace.spdx.json \
  --output bazel-bin/vulnerabilities_enriched.json \
  --github-token "${GITHUB_TOKEN}"

# With VulnCheck API key for exploit intelligence
bazel run //tools/supplychain:osv_query -- \
  --sbom bazel-bin/workspace.spdx.json \
  --output bazel-bin/vulnerabilities_enriched.json \
  --vulncheck-api-key "${VULNCHECK_API_KEY}"

# Disable enrichment (legacy mode)
bazel run //tools/supplychain:osv_query -- \
  --sbom bazel-bin/workspace.spdx.json \
  --output bazel-bin/vulnerabilities.json \
  --no-enrich

# Disable specific enrichment sources
bazel run //tools/supplychain:osv_query -- \
  --sbom bazel-bin/workspace.spdx.json \
  --output bazel-bin/vulnerabilities_enriched.json \
  --disable-vulncheck \
  --disable-ghsa
```

#### API Keys and Rate Limits

**Free tier limits (no API key required):**

- EPSS: Unlimited (public API)
- KEV: Unlimited (public dataset)
- GHSA: 60 req/hour (unauthenticated)

**With API keys (recommended):**

- GHSA: 5000 req/hour (with GitHub token)
- VulnCheck: 100 req/day (free tier)

**Set environment variables:**

```bash
export GITHUB_TOKEN="ghp_xxxxxxxxxxxxx"
export VULNCHECK_API_KEY="your-api-key"
```

#### Risk Scoring Algorithm

BazBOM calculates a composite risk score (0-100) based on:

```
Risk Score = (CVSS √ó 0.40) + (EPSS √ó 0.30) + (KEV √ó 0.20) + (Exploit √ó 0.10)
```

**Example:**

```json
{
  "cve": "CVE-2021-44228",
  "package": "log4j-core",
  "version": "2.14.1",
  "risk_score": 97.5,
  "priority": "P0-IMMEDIATE",
  "kev": {
    "in_kev": true,
    "vulnerability_name": "Log4Shell",
    "due_date": "2021-12-24"
  },
  "epss": {
    "epss_score": 0.97538,
    "exploitation_probability": "97.5%"
  },
  "exploit": {
    "weaponized": true
  }
}
```

## Validation

### Validate SPDX Documents

```bash
# Using the built-in validator
bazel run //tools/supplychain:validate_spdx -- \
  --input bazel-bin/path/to/package.spdx.json

# Using external SPDX validator
spdx-sbom-validator bazel-bin/path/to/package.spdx.json
```

### Validate SARIF Reports

```bash
# Using the built-in validator
bazel run //tools/supplychain:validate_sarif -- \
  --input bazel-bin/path/to/vulnerabilities.sarif.json
```

## Policy Enforcement

BazBOM includes a comprehensive policy enforcement tool to ensure supply chain security standards in CI/CD pipelines.

### Basic Policy Check

```bash
# Run policy check with default thresholds (0 critical vulnerabilities)
bazel build //:policy_check_report

# View policy report
cat bazel-bin/policy_check.json | jq
```

### Custom Policy Thresholds

```bash
# Strict policy: no critical/high vulnerabilities
python tools/supplychain/policy_check.py \
  --findings bazel-bin/sca_findings_filtered.json \
  --max-critical 0 \
  --max-high 0

# Flexible policy: allow some non-critical vulnerabilities
python tools/supplychain/policy_check.py \
  --findings bazel-bin/sca_findings_filtered.json \
  --max-critical 0 \
  --max-high 5 \
  --max-medium 20
```

**Exit codes:**
- `0`: All policies passed
- `1`: Policy violations found (CI should fail)

### Comprehensive Policy Check

```bash
# Check all reports: vulnerabilities, licenses, conflicts, risks
python tools/supplychain/policy_check.py \
  --findings bazel-bin/sca_findings_filtered.json \
  --license-report bazel-bin/license_report.json \
  --conflicts bazel-bin/conflicts.json \
  --risk-report bazel-bin/supply_chain_risks.json \
  --max-critical 0 \
  --max-high 5 \
  --output policy_report.json
```

### License Policy Enforcement

```bash
# Block specific licenses (e.g., GPL family)
python tools/supplychain/policy_check.py \
  --findings bazel-bin/sca_findings_filtered.json \
  --license-report bazel-bin/license_report.json \
  --blocked-licenses GPL-2.0 GPL-3.0 AGPL-3.0 \
  --block-license-conflicts \
  --flag-copyleft
```

### VEX Statement Requirements

```bash
# Require VEX statements for accepted risks
python tools/supplychain/policy_check.py \
  --findings bazel-bin/sca_findings_filtered.json \
  --require-vex-for-accepted \
  --max-critical 0
```

### Supply Chain Risk Policies

```bash
# Block typosquatting and unmaintained dependencies
python tools/supplychain/policy_check.py \
  --risk-report bazel-bin/supply_chain_risks.json \
  --block-typosquatting \
  --unmaintained-threshold 0
```

### CI/CD Integration

Add to `.github/workflows/supplychain.yml`:

```yaml
- name: Enforce Security Policies
  run: |
    bazel build //:policy_check_report
    
    # Policy check will fail (exit 1) if violations found
    python tools/supplychain/policy_check.py \
      --findings bazel-bin/sca_findings_filtered.json \
      --license-report bazel-bin/license_report.json \
      --conflicts bazel-bin/conflicts.json \
      --risk-report bazel-bin/supply_chain_risks.json \
      --max-critical 0 \
      --max-high 5 \
      --block-license-conflicts \
      --block-typosquatting
```

### Policy Violation Reports

Policy violations are categorized by severity:

```json
{
  "total_violations": 2,
  "violations": [
    {
      "severity": "CRITICAL",
      "rule": "max_critical_vulnerabilities",
      "message": "Found 2 critical vulnerabilities (max allowed: 0)",
      "details": {
        "count": 2,
        "threshold": 0
      }
    },
    {
      "severity": "HIGH",
      "rule": "blocked_license",
      "message": "Package foo uses blocked license: GPL-3.0",
      "details": {
        "package": "foo",
        "version": "1.0.0",
        "license": "GPL-3.0"
      }
    }
  ]
}
```

### Policy Configuration Examples

**Strict Production Policy:**
```bash
--max-critical 0 \
--max-high 0 \
--max-medium 5 \
--blocked-licenses GPL-2.0 GPL-3.0 AGPL-3.0 \
--block-license-conflicts \
--require-vex-for-accepted \
--block-typosquatting
```

**Development/Staging Policy:**
```bash
--max-critical 0 \
--max-high 10 \
--max-medium 50 \
--flag-copyleft \
--block-typosquatting
```

**Audit/Reporting Policy:**
```bash
--max-critical 999 \
--max-high 999 \
--flag-copyleft \
--output full-audit-report.json
```

## Working with Aspects

### List Dependencies

```bash
# Show all dependencies for a target
bazel query 'deps(//path/to:target)' --output package

# Show only direct dependencies
bazel query 'deps(//path/to:target, 1)' --output package
```

### Inspect Build Graph

```bash
# Generate dependency graph
bazel query 'deps(//path/to:target)' --output graph > graph.dot
dot -Tpng graph.dot -o graph.png
```

## Development Workflows

### Build Everything

```bash
bazel build //...
```

### Run All Tests

```bash
bazel test //...
```

### Clean Build Outputs

```bash
bazel clean
```

### Clean Everything (including downloaded dependencies)

```bash
bazel clean --expunge
```

## CI/CD Usage

### GitHub Actions

The repository includes pre-configured workflows:

```bash
# CI workflow runs on every push
# Builds, tests, and lints the code

# Supply chain workflow runs on main branch
# Generates SBOMs, runs SCA, uploads SARIF to GitHub Code Scanning
```

### Local CI Simulation

Run the same checks as CI locally:

```bash
# Lint
bazel run //tools/dev:lint

# Build
bazel build //...

# Test
bazel test //...

# Generate SBOMs
bazel build //:sbom_all

# Run SCA
bazel run //:sca_from_sbom
```

## Advanced Usage

### Custom SBOM Metadata

Edit `tools/supplychain/write_sbom.py` to customize:

- Document namespace
- Creator information
- Package supplier/originator
- License declarations

### Custom Vulnerability Policies

Create a custom policy file:

```json
{
  "ignore": ["CVE-2021-12345"],
  "fail_on": ["critical", "high"],
  "exceptions": {
    "package-name": ["CVE-2021-67890"]
  }
}
```

Apply it:

```bash
bazel run //:sca_from_sbom -- --policy policy.json
```

### Integration with Other Tools

Export SBOMs for use with other tools:

```bash
# Export for dependency-track
cp bazel-bin/path/to/package.spdx.json /path/to/dependency-track/import/

# Export for Grype
grype sbom:bazel-bin/path/to/package.spdx.json

# Export for Syft
syft convert bazel-bin/path/to/package.spdx.json -o cyclonedx-json
```

## Dependency Analysis

### Detect Version Conflicts

Identify dependencies with multiple versions in the same build:

```bash
bazel build //:conflict_report
cat bazel-bin/conflicts.json
```

The report includes:
- Package names with conflicts
- All conflicting versions
- Recommended resolution version
- Affected targets

### License Compliance Checking

Generate a comprehensive license compliance report:

```bash
bazel build //:license_report
cat bazel-bin/license_report.json
```

With additional flags:

```bash
# Flag copyleft licenses
bazel run //tools/supplychain:license_analyzer -- \
  --input bazel-bin/workspace_deps.json \
  --output license_report.json \
  --flag-copyleft

# Check for license conflicts
bazel run //tools/supplychain:license_analyzer -- \
  --input bazel-bin/workspace_deps.json \
  --output license_report.json \
  --check-conflicts \
  --flag-copyleft
```

### Generate PURL for Dependencies

Convert Maven coordinates to Package URLs (PURLs):

```bash
# Process dependencies file
bazel run //tools/supplychain:purl_generator -- \
  --input bazel-bin/workspace_deps.json \
  --output deps_with_purls.json

# Single coordinate conversion (for testing)
bazel run //tools/supplychain:purl_generator -- \
  --coordinates "com.google.guava:guava:31.1-jre"
```

### Aggregate Supply Chain Metrics

Generate comprehensive metrics dashboard:

```bash
bazel build //:metrics_report
cat bazel-bin/supply_chain_metrics.json
```

The metrics include:
- Vulnerability counts by severity
- Dependency statistics (total, direct, transitive, conflicts)
- License distribution
- Copyleft and unknown license counts

For text format output:

```bash
bazel run //tools/supplychain:metrics_aggregator -- \
  --sbom bazel-bin/workspace_sbom.spdx.json \
  --sca-findings bazel-bin/sca_findings.json \
  --license-report bazel-bin/license_report.json \
  --conflicts bazel-bin/conflicts.json \
  --output metrics.txt \
  --format text
```

## Performance Optimization

### Use Configuration Profiles

BazBOM includes pre-configured Bazel profiles:

```bash
# Standard supply chain analysis
bazel build --config=supplychain //:sbom_all

# Incremental mode (faster for PRs)
bazel build --config=supplychain-incremental //:sbom_all

# Full analysis with all features
bazel build --config=supplychain-full //:supply_chain_all

# Offline mode (no network access)
bazel build --config=supplychain-offline //:sbom_all
```

### Enable Remote Caching

For team environments, configure remote cache in `.bazelrc`:

```bash
build:remote-cache --remote_cache=https://cache.example.com
build:remote-cache --experimental_remote_cache_compression
```

Then use:

```bash
bazel build --config=remote-cache //...
```

## Supply Chain Risk Analysis

### Detect Typosquatting and Outdated Packages

Run supply chain risk analysis to detect:
- Typosquatting attempts (similar package names)
- Outdated dependencies
- Deprecated packages

```bash
bazel build //:supply_chain_risk_report
cat bazel-bin/supply_chain_risks.json
```

The report includes:
- Typosquatting findings (packages similar to popular ones)
- Outdated version information with latest available versions
- Unmaintained dependency detection
- Risk severity levels

Manual execution with options:

```bash
# Check for typosquatting only
bazel run //tools/supplychain:supply_chain_risk -- \
  --sbom bazel-bin/workspace_sbom.spdx.json \
  --output risks.json \
  --check-typosquatting

# Check for deprecated packages (requires network)
bazel run //tools/supplychain:supply_chain_risk -- \
  --sbom bazel-bin/workspace_sbom.spdx.json \
  --output risks.json \
  --check-deprecated

# Offline mode
bazel run //tools/supplychain:supply_chain_risk -- \
  --sbom bazel-bin/workspace_sbom.spdx.json \
  --output risks.json \
  --offline-mode
```

## VEX (Vulnerability Exploitability eXchange)

### Create VEX Statements

Create VEX statements to suppress false positives or document accepted risks:

```bash
# Create a VEX statement file
cat > vex/statements/CVE-2023-12345.json <<EOF
{
  "cve": "CVE-2023-12345",
  "package": "pkg:maven/com.example/vulnerable@1.0.0",
  "status": "not_affected",
  "justification": "Vulnerable code path not used in our application",
  "created": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "author": "Security Team"
}
EOF
```

Valid status values:
- `not_affected` - Vulnerability doesn't affect this package/version
- `false_positive` - Scanner incorrectly flagged this
- `mitigated` - Risk mitigated by other controls
- `accepted_risk` - Known and accepted by security team

### Apply VEX Statements

Apply VEX statements to filter vulnerability findings:

```bash
# Apply during build
bazel build //:sca_findings_with_vex
cat bazel-bin/sca_findings_filtered.json

# Manual application
bazel run //tools/supplychain:vex_processor -- \
  --vex-dir=vex/statements \
  --sca-findings=bazel-bin/sca_findings.json \
  --output=sca_findings_filtered.json \
  --suppressed-output=suppressed.json
```

### Validate VEX Statements

Validate VEX statement format before committing:

```bash
bazel run //tools/supplychain:vex_processor -- \
  --vex-dir=vex/statements \
  --sca-findings=bazel-bin/sca_findings.json \
  --output=/tmp/filtered.json \
  --validate-only
```

See [docs/vex/README.md](vex/README.md) for more details on VEX format and best practices.

## Incremental Analysis

### Git-Based Incremental Builds

For faster CI/CD on large repositories, analyze only changed targets:

```bash
# Detect changed targets since last commit
bazel run //tools/supplychain:incremental_analyzer -- \
  --workspace=. \
  --base-ref=HEAD~1 \
  --output-format=targets

# Use output in build commands
TARGETS=$(bazel run //tools/supplychain:incremental_analyzer -- \
  --base-ref=origin/main \
  --output-format=targets)
bazel build $TARGETS
```

Output formats:
- `targets` - Space-separated Bazel target list
- `json` - Detailed JSON with changed files and affected targets
- `bazel-query` - Format suitable for `bazel query` commands

Example in CI:

```yaml
- name: Incremental Analysis
  run: |
    CHANGED=$(bazel run //tools/supplychain:incremental_analyzer -- \
      --base-ref=${{ github.event.pull_request.base.sha }} \
      --output-format=targets)
    if [ -n "$CHANGED" ]; then
      bazel build $CHANGED
    else
      echo "No changes detected, running full analysis"
      bazel build //...
    fi
```

## Troubleshooting

For common issues and solutions, see [TROUBLESHOOTING.md](TROUBLESHOOTING.md).

## Performance Benchmarking

BazBOM includes a comprehensive benchmark suite to measure performance against other SBOM tools:

```bash
# Run benchmarks for BazBOM
bazel run //benchmarks:runner -- --tools bazbom --sizes all

# Compare against other tools
bazel run //benchmarks:runner -- --tools bazbom syft --sizes all --leaderboard

# Test specific repository sizes
bazel run //benchmarks:runner -- --tools bazbom --sizes small_100_deps medium_500_deps
```

**Output:**
- `benchmarks/results/benchmark_results.json` - Detailed metrics
- `benchmarks/results/leaderboard.md` - Human-readable comparison

See [docs/benchmarks/README.md](benchmarks/README.md) for creating custom benchmark repositories.

## AI-Powered Query Interface

Query your SBOMs using natural language:

```bash
# Interactive mode
bazel run //tools/supplychain:ai_query_engine -- --sbom app.spdx.json

# Single query
bazel run //tools/supplychain:ai_query_engine -- \
  --sbom app.spdx.json \
  --query "What packages use log4j?"

# JSON output for automation
bazel run //tools/supplychain:ai_query_engine -- \
  --sbom app.spdx.json \
  --query "Show GPL dependencies" \
  --json
```

**Supported queries:**
- Dependency searches: "What uses log4j?", "Show guava dependencies"
- License queries: "Show GPL dependencies", "List Apache-licensed packages"
- Vulnerability queries: "Which packages are vulnerable?", "Show CVE-2021-44228"
- Statistics: "How many dependencies?", "Show statistics"

## Upgrade Recommendations

Get AI-powered upgrade recommendations with breaking change analysis:

```bash
# Get upgrade recommendation
bazel run //tools/supplychain:upgrade_recommender -- \
  --package com.google.guava:guava \
  --current 30.1-jre \
  --versions 31.0-jre 31.1-jre 32.0-jre

# With changelog analysis
bazel run //tools/supplychain:upgrade_recommender -- \
  --package com.google.guava:guava \
  --current 30.1-jre \
  --changelog path/to/CHANGELOG.md

# JSON output for automation
bazel run //tools/supplychain:upgrade_recommender -- \
  --package com.google.guava:guava \
  --current 30.1-jre \
  --json
```

**Output includes:**
- Recommended version (balancing safety and updates)
- Latest available version
- Compatibility score (0-100%)
- Effort estimate (LOW, MEDIUM, HIGH)
- Breaking changes identified
- Migration guide with steps
- Security fixes (when available)
